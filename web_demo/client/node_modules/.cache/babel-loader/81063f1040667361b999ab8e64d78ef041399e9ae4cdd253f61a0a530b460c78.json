{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Process ![image](<src> \"title\")\n\nimport { normalizeReference, isSpace } from '../common/utils.mjs';\nexport default function image(state, silent) {\n  let code, content, label, pos, ref, res, title, start;\n  let href = '';\n  const oldPos = state.pos;\n  const max = state.posMax;\n  if (state.src.charCodeAt(state.pos) !== 0x21 /* ! */) {\n    return false;\n  }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B /* [ */) {\n    return false;\n  }\n  const labelStart = state.pos + 2;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) {\n    return false;\n  }\n  pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) {\n        break;\n      }\n    }\n    if (pos >= max) {\n      return false;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) {\n        break;\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str;\n      pos = res.pos;\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) {\n          break;\n        }\n      }\n    } else {\n      title = '';\n    }\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {\n      state.pos = oldPos;\n      return false;\n    }\n    pos++;\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') {\n      return false;\n    }\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      label = state.src.slice(labelStart, labelEnd);\n    }\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd);\n    const tokens = [];\n    state.md.inline.parse(content, state.md, state.env, tokens);\n    const token = state.push('image', 'img', 0);\n    const attrs = [['src', href], ['alt', '']];\n    token.attrs = attrs;\n    token.children = tokens;\n    token.content = content;\n    if (title) {\n      attrs.push(['title', title]);\n    }\n  }\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}","map":{"version":3,"names":["normalizeReference","isSpace","image","state","silent","code","content","label","pos","ref","res","title","start","href","oldPos","max","posMax","src","charCodeAt","labelStart","labelEnd","md","helpers","parseLinkLabel","parseLinkDestination","ok","normalizeLink","str","validateLink","parseLinkTitle","env","references","slice","tokens","inline","parse","token","push","attrs","children"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_inline/image.mjs"],"sourcesContent":["// Process ![image](<src> \"title\")\n\nimport { normalizeReference, isSpace } from '../common/utils.mjs'\n\nexport default function image (state, silent) {\n  let code, content, label, pos, ref, res, title, start\n  let href = ''\n  const oldPos = state.pos\n  const max = state.posMax\n\n  if (state.src.charCodeAt(state.pos) !== 0x21/* ! */) { return false }\n  if (state.src.charCodeAt(state.pos + 1) !== 0x5B/* [ */) { return false }\n\n  const labelStart = state.pos + 2\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos + 1, false)\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false }\n\n  pos = labelEnd + 1\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!isSpace(code) && code !== 0x0A) { break }\n    }\n    if (pos >= max) { return false }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax)\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str)\n      if (state.md.validateLink(href)) {\n        pos = res.pos\n      } else {\n        href = ''\n      }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                ^^ skipping these spaces\n    start = pos\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!isSpace(code) && code !== 0x0A) { break }\n    }\n\n    // [link](  <href>  \"title\"  )\n    //                  ^^^^^^^ parsing link title\n    res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax)\n    if (pos < max && start !== pos && res.ok) {\n      title = res.str\n      pos = res.pos\n\n      // [link](  <href>  \"title\"  )\n      //                         ^^ skipping these spaces\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos)\n        if (!isSpace(code) && code !== 0x0A) { break }\n      }\n    } else {\n      title = ''\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      state.pos = oldPos\n      return false\n    }\n    pos++\n  } else {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1\n      pos = state.md.helpers.parseLinkLabel(state, pos)\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++)\n      } else {\n        pos = labelEnd + 1\n      }\n    } else {\n      pos = labelEnd + 1\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd) }\n\n    ref = state.env.references[normalizeReference(label)]\n    if (!ref) {\n      state.pos = oldPos\n      return false\n    }\n    href = ref.href\n    title = ref.title\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    content = state.src.slice(labelStart, labelEnd)\n\n    const tokens = []\n    state.md.inline.parse(\n      content,\n      state.md,\n      state.env,\n      tokens\n    )\n\n    const token = state.push('image', 'img', 0)\n    const attrs = [['src', href], ['alt', '']]\n    token.attrs = attrs\n    token.children = tokens\n    token.content = content\n\n    if (title) {\n      attrs.push(['title', title])\n    }\n  }\n\n  state.pos = pos\n  state.posMax = max\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}