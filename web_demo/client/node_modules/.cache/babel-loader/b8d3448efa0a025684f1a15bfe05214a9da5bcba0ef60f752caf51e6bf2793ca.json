{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Parser state class\n\nimport Token from '../token.mjs';\nimport { isSpace } from '../common/utils.mjs';\nfunction StateBlock(src, md, env, tokens) {\n  this.src = src;\n\n  // link to parser instance\n  this.md = md;\n  this.env = env;\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n  this.eMarks = []; // line end offsets for fast jumps\n  this.tShift = []; // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = []; // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = [];\n\n  // block parser variables\n\n  // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n  this.blkIndent = 0;\n  this.line = 0; // line index in src\n  this.lineMax = 0; // lines count\n  this.tight = false; // loose/tight mode for lists\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1; // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root';\n  this.level = 0;\n\n  // Create caches\n  // Generate markers.\n  const s = this.src;\n  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {\n    const ch = s.charCodeAt(pos);\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++;\n        if (ch === 0x09) {\n          offset += 4 - offset % 4;\n        } else {\n          offset++;\n        }\n        continue;\n      } else {\n        indent_found = true;\n      }\n    }\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      this.sCount.push(offset);\n      this.bsCount.push(0);\n      indent_found = false;\n      indent = 0;\n      offset = 0;\n      start = pos + 1;\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.sCount.push(0);\n  this.bsCount.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  const token = new Token(type, tag, nesting);\n  token.block = true;\n  if (nesting < 0) this.level--; // closing tag\n  token.level = this.level;\n  if (nesting > 0) this.level++; // opening tag\n\n  this.tokens.push(token);\n  return token;\n};\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (let max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n  return from;\n};\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (let max = this.src.length; pos < max; pos++) {\n    const ch = this.src.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      break;\n    }\n  }\n  return pos;\n};\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack(pos, min) {\n  if (pos <= min) {\n    return pos;\n  }\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) {\n      return pos + 1;\n    }\n  }\n  return pos;\n};\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (let max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n  return pos;\n};\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n  return pos;\n};\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  if (begin >= end) {\n    return '';\n  }\n  const queue = new Array(end - begin);\n  for (let i = 0, line = begin; line < end; line++, i++) {\n    let lineIndent = 0;\n    const lineStart = this.bMarks[line];\n    let first = lineStart;\n    let last;\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n    while (first < last && lineIndent < indent) {\n      const ch = this.src.charCodeAt(first);\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4;\n        } else {\n          lineIndent++;\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++;\n      } else {\n        break;\n      }\n      first++;\n    }\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last);\n    } else {\n      queue[i] = this.src.slice(first, last);\n    }\n  }\n  return queue.join('');\n};\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token;\nexport default StateBlock;","map":{"version":3,"names":["Token","isSpace","StateBlock","src","md","env","tokens","bMarks","eMarks","tShift","sCount","bsCount","blkIndent","line","lineMax","tight","ddIndent","listIndent","parentType","level","s","start","pos","indent","offset","len","length","indent_found","ch","charCodeAt","push","prototype","type","tag","nesting","token","block","isEmpty","skipEmptyLines","from","max","skipSpaces","skipSpacesBack","min","skipChars","code","skipCharsBack","getLines","begin","end","keepLastLF","queue","Array","i","lineIndent","lineStart","first","last","join","slice"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_block/state_block.mjs"],"sourcesContent":["// Parser state class\n\nimport Token from '../token.mjs'\nimport { isSpace } from '../common/utils.mjs'\n\nfunction StateBlock (src, md, env, tokens) {\n  this.src = src\n\n  // link to parser instance\n  this.md     = md\n\n  this.env = env\n\n  //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens\n\n  this.bMarks = []  // line begin offsets for fast jumps\n  this.eMarks = []  // line end offsets for fast jumps\n  this.tShift = []  // offsets of the first non-space characters (tabs not expanded)\n  this.sCount = []  // indents for each line (tabs expanded)\n\n  // An amount of virtual spaces (tabs expanded) between beginning\n  // of each line (bMarks) and real beginning of that line.\n  //\n  // It exists only as a hack because blockquotes override bMarks\n  // losing information in the process.\n  //\n  // It's used only when expanding tabs, you can think about it as\n  // an initial tab length, e.g. bsCount=21 applied to string `\\t123`\n  // means first tab should be expanded to 4-21%4 === 3 spaces.\n  //\n  this.bsCount = []\n\n  // block parser variables\n\n  // required block content indent (for example, if we are\n  // inside a list, it would be positioned after list marker)\n  this.blkIndent  = 0\n  this.line       = 0 // line index in src\n  this.lineMax    = 0 // lines count\n  this.tight      = false  // loose/tight mode for lists\n  this.ddIndent   = -1 // indent of the current dd block (-1 if there isn't any)\n  this.listIndent = -1 // indent of the current list block (-1 if there isn't any)\n\n  // can be 'blockquote', 'list', 'root', 'paragraph' or 'reference'\n  // used in lists to determine if they interrupt a paragraph\n  this.parentType = 'root'\n\n  this.level = 0\n\n  // Create caches\n  // Generate markers.\n  const s = this.src\n\n  for (let start = 0, pos = 0, indent = 0, offset = 0, len = s.length, indent_found = false; pos < len; pos++) {\n    const ch = s.charCodeAt(pos)\n\n    if (!indent_found) {\n      if (isSpace(ch)) {\n        indent++\n\n        if (ch === 0x09) {\n          offset += 4 - offset % 4\n        } else {\n          offset++\n        }\n        continue\n      } else {\n        indent_found = true\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) { pos++ }\n      this.bMarks.push(start)\n      this.eMarks.push(pos)\n      this.tShift.push(indent)\n      this.sCount.push(offset)\n      this.bsCount.push(0)\n\n      indent_found = false\n      indent = 0\n      offset = 0\n      start = pos + 1\n    }\n  }\n\n  // Push fake entry to simplify cache bounds checks\n  this.bMarks.push(s.length)\n  this.eMarks.push(s.length)\n  this.tShift.push(0)\n  this.sCount.push(0)\n  this.bsCount.push(0)\n\n  this.lineMax = this.bMarks.length - 1 // don't count last fake line\n}\n\n// Push new token to \"stream\".\n//\nStateBlock.prototype.push = function (type, tag, nesting) {\n  const token = new Token(type, tag, nesting)\n  token.block = true\n\n  if (nesting < 0) this.level-- // closing tag\n  token.level = this.level\n  if (nesting > 0) this.level++ // opening tag\n\n  this.tokens.push(token)\n  return token\n}\n\nStateBlock.prototype.isEmpty = function isEmpty (line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line]\n}\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines (from) {\n  for (let max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break\n    }\n  }\n  return from\n}\n\n// Skip spaces from given position.\nStateBlock.prototype.skipSpaces = function skipSpaces (pos) {\n  for (let max = this.src.length; pos < max; pos++) {\n    const ch = this.src.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n  }\n  return pos\n}\n\n// Skip spaces from given position in reverse.\nStateBlock.prototype.skipSpacesBack = function skipSpacesBack (pos, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (!isSpace(this.src.charCodeAt(--pos))) { return pos + 1 }\n  }\n  return pos\n}\n\n// Skip char codes from given position\nStateBlock.prototype.skipChars = function skipChars (pos, code) {\n  for (let max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) { break }\n  }\n  return pos\n}\n\n// Skip char codes reverse from given position - 1\nStateBlock.prototype.skipCharsBack = function skipCharsBack (pos, code, min) {\n  if (pos <= min) { return pos }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) { return pos + 1 }\n  }\n  return pos\n}\n\n// cut lines range from source.\nStateBlock.prototype.getLines = function getLines (begin, end, indent, keepLastLF) {\n  if (begin >= end) {\n    return ''\n  }\n\n  const queue = new Array(end - begin)\n\n  for (let i = 0, line = begin; line < end; line++, i++) {\n    let lineIndent = 0\n    const lineStart = this.bMarks[line]\n    let first = lineStart\n    let last\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1\n    } else {\n      last = this.eMarks[line]\n    }\n\n    while (first < last && lineIndent < indent) {\n      const ch = this.src.charCodeAt(first)\n\n      if (isSpace(ch)) {\n        if (ch === 0x09) {\n          lineIndent += 4 - (lineIndent + this.bsCount[line]) % 4\n        } else {\n          lineIndent++\n        }\n      } else if (first - lineStart < this.tShift[line]) {\n        // patched tShift masked characters to look like spaces (blockquotes, list markers)\n        lineIndent++\n      } else {\n        break\n      }\n\n      first++\n    }\n\n    if (lineIndent > indent) {\n      // partially expanding tabs in code blocks, e.g '\\t\\tfoobar'\n      // with indent=2 becomes '  \\tfoobar'\n      queue[i] = new Array(lineIndent - indent + 1).join(' ') + this.src.slice(first, last)\n    } else {\n      queue[i] = this.src.slice(first, last)\n    }\n  }\n\n  return queue.join('')\n}\n\n// re-export Token class to use in block rules\nStateBlock.prototype.Token = Token\n\nexport default StateBlock\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}