{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n\nimport { arrayReplaceAt } from '../common/utils.mjs';\nfunction isLinkOpen(str) {\n  return /^<a[>\\s]/i.test(str);\n}\nfunction isLinkClose(str) {\n  return /^<\\/a\\s*>/i.test(str);\n}\nexport default function linkify(state) {\n  const blockTokens = state.tokens;\n  if (!state.md.options.linkify) {\n    return;\n  }\n  for (let j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' || !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue;\n    }\n    let tokens = blockTokens[j].children;\n    let htmlLinkLevel = 0;\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const currentToken = tokens[i];\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--;\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--;\n        }\n        continue;\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--;\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++;\n        }\n      }\n      if (htmlLinkLevel > 0) {\n        continue;\n      }\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n        const text = currentToken.content;\n        let links = state.md.linkify.match(text);\n\n        // Now split string to nodes\n        const nodes = [];\n        let level = currentToken.level;\n        let lastPos = 0;\n\n        // forbid escape sequence at the start of the string,\n        // this avoids http\\://example.com/ from being linkified as\n        // http:<a href=\"//example.com/\">//example.com/</a>\n        if (links.length > 0 && links[0].index === 0 && i > 0 && tokens[i - 1].type === 'text_special') {\n          links = links.slice(1);\n        }\n        for (let ln = 0; ln < links.length; ln++) {\n          const url = links[ln].url;\n          const fullUrl = state.md.normalizeLink(url);\n          if (!state.md.validateLink(fullUrl)) {\n            continue;\n          }\n          let urlText = links[ln].text;\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '');\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '');\n          } else {\n            urlText = state.md.normalizeLinkText(urlText);\n          }\n          const pos = links[ln].index;\n          if (pos > lastPos) {\n            const token = new state.Token('text', '', 0);\n            token.content = text.slice(lastPos, pos);\n            token.level = level;\n            nodes.push(token);\n          }\n          const token_o = new state.Token('link_open', 'a', 1);\n          token_o.attrs = [['href', fullUrl]];\n          token_o.level = level++;\n          token_o.markup = 'linkify';\n          token_o.info = 'auto';\n          nodes.push(token_o);\n          const token_t = new state.Token('text', '', 0);\n          token_t.content = urlText;\n          token_t.level = level;\n          nodes.push(token_t);\n          const token_c = new state.Token('link_close', 'a', -1);\n          token_c.level = --level;\n          token_c.markup = 'linkify';\n          token_c.info = 'auto';\n          nodes.push(token_c);\n          lastPos = links[ln].lastIndex;\n        }\n        if (lastPos < text.length) {\n          const token = new state.Token('text', '', 0);\n          token.content = text.slice(lastPos);\n          token.level = level;\n          nodes.push(token);\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes);\n      }\n    }\n  }\n}","map":{"version":3,"names":["arrayReplaceAt","isLinkOpen","str","test","isLinkClose","linkify","state","blockTokens","tokens","md","options","j","l","length","type","pretest","content","children","htmlLinkLevel","i","currentToken","level","text","links","match","nodes","lastPos","index","slice","ln","url","fullUrl","normalizeLink","validateLink","urlText","schema","normalizeLinkText","replace","pos","token","Token","push","token_o","attrs","markup","info","token_t","token_c","lastIndex"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_core/linkify.mjs"],"sourcesContent":["// Replace link-like texts with link nodes.\n//\n// Currently restricted by `md.validateLink()` to http/https/ftp\n//\n\nimport { arrayReplaceAt } from '../common/utils.mjs'\n\nfunction isLinkOpen (str) {\n  return /^<a[>\\s]/i.test(str)\n}\nfunction isLinkClose (str) {\n  return /^<\\/a\\s*>/i.test(str)\n}\n\nexport default function linkify (state) {\n  const blockTokens = state.tokens\n\n  if (!state.md.options.linkify) { return }\n\n  for (let j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline' ||\n        !state.md.linkify.pretest(blockTokens[j].content)) {\n      continue\n    }\n\n    let tokens = blockTokens[j].children\n\n    let htmlLinkLevel = 0\n\n    // We scan from the end, to keep position when new tags added.\n    // Use reversed logic in links start/end match\n    for (let i = tokens.length - 1; i >= 0; i--) {\n      const currentToken = tokens[i]\n\n      // Skip content of markdown links\n      if (currentToken.type === 'link_close') {\n        i--\n        while (tokens[i].level !== currentToken.level && tokens[i].type !== 'link_open') {\n          i--\n        }\n        continue\n      }\n\n      // Skip content of html tag links\n      if (currentToken.type === 'html_inline') {\n        if (isLinkOpen(currentToken.content) && htmlLinkLevel > 0) {\n          htmlLinkLevel--\n        }\n        if (isLinkClose(currentToken.content)) {\n          htmlLinkLevel++\n        }\n      }\n      if (htmlLinkLevel > 0) { continue }\n\n      if (currentToken.type === 'text' && state.md.linkify.test(currentToken.content)) {\n        const text = currentToken.content\n        let links = state.md.linkify.match(text)\n\n        // Now split string to nodes\n        const nodes = []\n        let level = currentToken.level\n        let lastPos = 0\n\n        // forbid escape sequence at the start of the string,\n        // this avoids http\\://example.com/ from being linkified as\n        // http:<a href=\"//example.com/\">//example.com/</a>\n        if (links.length > 0 &&\n            links[0].index === 0 &&\n            i > 0 &&\n            tokens[i - 1].type === 'text_special') {\n          links = links.slice(1)\n        }\n\n        for (let ln = 0; ln < links.length; ln++) {\n          const url = links[ln].url\n          const fullUrl = state.md.normalizeLink(url)\n          if (!state.md.validateLink(fullUrl)) { continue }\n\n          let urlText = links[ln].text\n\n          // Linkifier might send raw hostnames like \"example.com\", where url\n          // starts with domain name. So we prepend http:// in those cases,\n          // and remove it afterwards.\n          //\n          if (!links[ln].schema) {\n            urlText = state.md.normalizeLinkText('http://' + urlText).replace(/^http:\\/\\//, '')\n          } else if (links[ln].schema === 'mailto:' && !/^mailto:/i.test(urlText)) {\n            urlText = state.md.normalizeLinkText('mailto:' + urlText).replace(/^mailto:/, '')\n          } else {\n            urlText = state.md.normalizeLinkText(urlText)\n          }\n\n          const pos = links[ln].index\n\n          if (pos > lastPos) {\n            const token   = new state.Token('text', '', 0)\n            token.content = text.slice(lastPos, pos)\n            token.level   = level\n            nodes.push(token)\n          }\n\n          const token_o   = new state.Token('link_open', 'a', 1)\n          token_o.attrs   = [['href', fullUrl]]\n          token_o.level   = level++\n          token_o.markup  = 'linkify'\n          token_o.info    = 'auto'\n          nodes.push(token_o)\n\n          const token_t   = new state.Token('text', '', 0)\n          token_t.content = urlText\n          token_t.level   = level\n          nodes.push(token_t)\n\n          const token_c   = new state.Token('link_close', 'a', -1)\n          token_c.level   = --level\n          token_c.markup  = 'linkify'\n          token_c.info    = 'auto'\n          nodes.push(token_c)\n\n          lastPos = links[ln].lastIndex\n        }\n        if (lastPos < text.length) {\n          const token   = new state.Token('text', '', 0)\n          token.content = text.slice(lastPos)\n          token.level   = level\n          nodes.push(token)\n        }\n\n        // replace current node\n        blockTokens[j].children = tokens = arrayReplaceAt(tokens, i, nodes)\n      }\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}