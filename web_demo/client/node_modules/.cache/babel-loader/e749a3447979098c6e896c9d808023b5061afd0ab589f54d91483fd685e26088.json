{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// fences (``` lang, ~~~ lang)\n\nexport default function fence(state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  let max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (pos + 3 > max) {\n    return false;\n  }\n  const marker = state.src.charCodeAt(pos);\n  if (marker !== 0x7E /* ~ */ && marker !== 0x60 /* ` */) {\n    return false;\n  }\n\n  // scan marker length\n  let mem = pos;\n  pos = state.skipChars(pos, marker);\n  let len = pos - mem;\n  if (len < 3) {\n    return false;\n  }\n  const markup = state.src.slice(mem, pos);\n  const params = state.src.slice(pos, max);\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false;\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) {\n    return true;\n  }\n\n  // search end of block\n  let nextLine = startLine;\n  let haveEndMarker = false;\n  for (;;) {\n    nextLine++;\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n    pos = state.skipChars(pos, marker);\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) {\n      continue;\n    }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos);\n    if (pos < max) {\n      continue;\n    }\n    haveEndMarker = true;\n    // found!\n    break;\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  const token = state.push('fence', 'code', 0);\n  token.info = params;\n  token.content = state.getLines(startLine + 1, nextLine, len, true);\n  token.markup = markup;\n  token.map = [startLine, state.line];\n  return true;\n}","map":{"version":3,"names":["fence","state","startLine","endLine","silent","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","marker","src","charCodeAt","mem","skipChars","len","markup","slice","params","indexOf","String","fromCharCode","nextLine","haveEndMarker","skipSpaces","line","token","push","info","content","getLines","map"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_block/fence.mjs"],"sourcesContent":["// fences (``` lang, ~~~ lang)\n\nexport default function fence (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (pos + 3 > max) { return false }\n\n  const marker = state.src.charCodeAt(pos)\n\n  if (marker !== 0x7E/* ~ */ && marker !== 0x60 /* ` */) {\n    return false\n  }\n\n  // scan marker length\n  let mem = pos\n  pos = state.skipChars(pos, marker)\n\n  let len = pos - mem\n\n  if (len < 3) { return false }\n\n  const markup = state.src.slice(mem, pos)\n  const params = state.src.slice(pos, max)\n\n  if (marker === 0x60 /* ` */) {\n    if (params.indexOf(String.fromCharCode(marker)) >= 0) {\n      return false\n    }\n  }\n\n  // Since start is found, we can report success here in validation mode\n  if (silent) { return true }\n\n  // search end of block\n  let nextLine = startLine\n  let haveEndMarker = false\n\n  for (;;) {\n    nextLine++\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine]\n    max = state.eMarks[nextLine]\n\n    if (pos < max && state.sCount[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) { continue }\n\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue\n    }\n\n    pos = state.skipChars(pos, marker)\n\n    // closing code fence must be at least as long as the opening one\n    if (pos - mem < len) { continue }\n\n    // make sure tail has spaces only\n    pos = state.skipSpaces(pos)\n\n    if (pos < max) { continue }\n\n    haveEndMarker = true\n    // found!\n    break\n  }\n\n  // If a fence has heading spaces, they should be removed from its inner block\n  len = state.sCount[startLine]\n\n  state.line = nextLine + (haveEndMarker ? 1 : 0)\n\n  const token   = state.push('fence', 'code', 0)\n  token.info    = params\n  token.content = state.getLines(startLine + 1, nextLine, len, true)\n  token.markup  = markup\n  token.map     = [startLine, state.line]\n\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}