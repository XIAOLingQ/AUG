{"ast":null,"code":"// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n\nexport default function parseLinkLabel(state, start, disableNested) {\n  let level, found, marker, prevPos;\n  const max = state.posMax;\n  const oldPos = state.pos;\n  state.pos = start + 1;\n  level = 1;\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n    if (marker === 0x5D /* ] */) {\n      level--;\n      if (level === 0) {\n        found = true;\n        break;\n      }\n    }\n    prevPos = state.pos;\n    state.md.inline.skipToken(state);\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++;\n      } else if (disableNested) {\n        state.pos = oldPos;\n        return -1;\n      }\n    }\n  }\n  let labelEnd = -1;\n  if (found) {\n    labelEnd = state.pos;\n  }\n\n  // restore old state\n  state.pos = oldPos;\n  return labelEnd;\n}","map":{"version":3,"names":["parseLinkLabel","state","start","disableNested","level","found","marker","prevPos","max","posMax","oldPos","pos","src","charCodeAt","md","inline","skipToken","labelEnd"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/helpers/parse_link_label.mjs"],"sourcesContent":["// Parse link label\n//\n// this function assumes that first character (\"[\") already matches;\n// returns the end of the label\n//\n\nexport default function parseLinkLabel (state, start, disableNested) {\n  let level, found, marker, prevPos\n\n  const max = state.posMax\n  const oldPos = state.pos\n\n  state.pos = start + 1\n  level = 1\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos)\n    if (marker === 0x5D /* ] */) {\n      level--\n      if (level === 0) {\n        found = true\n        break\n      }\n    }\n\n    prevPos = state.pos\n    state.md.inline.skipToken(state)\n    if (marker === 0x5B /* [ */) {\n      if (prevPos === state.pos - 1) {\n        // increase level if we find text `[`, which is not a part of any token\n        level++\n      } else if (disableNested) {\n        state.pos = oldPos\n        return -1\n      }\n    }\n  }\n\n  let labelEnd = -1\n\n  if (found) {\n    labelEnd = state.pos\n  }\n\n  // restore old state\n  state.pos = oldPos\n\n  return labelEnd\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASA,cAAcA,CAAEC,KAAK,EAAEC,KAAK,EAAEC,aAAa,EAAE;EACnE,IAAIC,KAAK,EAAEC,KAAK,EAAEC,MAAM,EAAEC,OAAO;EAEjC,MAAMC,GAAG,GAAGP,KAAK,CAACQ,MAAM;EACxB,MAAMC,MAAM,GAAGT,KAAK,CAACU,GAAG;EAExBV,KAAK,CAACU,GAAG,GAAGT,KAAK,GAAG,CAAC;EACrBE,KAAK,GAAG,CAAC;EAET,OAAOH,KAAK,CAACU,GAAG,GAAGH,GAAG,EAAE;IACtBF,MAAM,GAAGL,KAAK,CAACW,GAAG,CAACC,UAAU,CAACZ,KAAK,CAACU,GAAG,CAAC;IACxC,IAAIL,MAAM,KAAK,IAAI,CAAC,SAAS;MAC3BF,KAAK,EAAE;MACP,IAAIA,KAAK,KAAK,CAAC,EAAE;QACfC,KAAK,GAAG,IAAI;QACZ;MACF;IACF;IAEAE,OAAO,GAAGN,KAAK,CAACU,GAAG;IACnBV,KAAK,CAACa,EAAE,CAACC,MAAM,CAACC,SAAS,CAACf,KAAK,CAAC;IAChC,IAAIK,MAAM,KAAK,IAAI,CAAC,SAAS;MAC3B,IAAIC,OAAO,KAAKN,KAAK,CAACU,GAAG,GAAG,CAAC,EAAE;QAC7B;QACAP,KAAK,EAAE;MACT,CAAC,MAAM,IAAID,aAAa,EAAE;QACxBF,KAAK,CAACU,GAAG,GAAGD,MAAM;QAClB,OAAO,CAAC,CAAC;MACX;IACF;EACF;EAEA,IAAIO,QAAQ,GAAG,CAAC,CAAC;EAEjB,IAAIZ,KAAK,EAAE;IACTY,QAAQ,GAAGhB,KAAK,CAACU,GAAG;EACtB;;EAEA;EACAV,KAAK,CAACU,GAAG,GAAGD,MAAM;EAElB,OAAOO,QAAQ;AACjB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}