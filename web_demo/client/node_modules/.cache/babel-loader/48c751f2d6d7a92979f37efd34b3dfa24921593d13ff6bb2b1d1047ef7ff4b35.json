{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Lists\n\nimport { isSpace } from '../common/utils.mjs';\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker(state, startLine) {\n  const max = state.eMarks[startLine];\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  const marker = state.src.charCodeAt(pos++);\n  // Check bullet\n  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x2B /* + */) {\n    return -1;\n  }\n  if (pos < max) {\n    const ch = state.src.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker(state, startLine) {\n  const start = state.bMarks[startLine] + state.tShift[startLine];\n  const max = state.eMarks[startLine];\n  let pos = start;\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) {\n    return -1;\n  }\n  let ch = state.src.charCodeAt(pos++);\n  if (ch < 0x30 /* 0 */ || ch > 0x39 /* 9 */) {\n    return -1;\n  }\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n    ch = state.src.charCodeAt(pos++);\n    if (ch >= 0x30 /* 0 */ && ch <= 0x39 /* 9 */) {\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) {\n        return -1;\n      }\n      continue;\n    }\n\n    // found valid marker\n    if (ch === 0x29 /* ) */ || ch === 0x2e /* . */) {\n      break;\n    }\n    return -1;\n  }\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n  }\n  return pos;\n}\nfunction markTightParagraphs(state, idx) {\n  const level = state.level + 2;\n  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true;\n      state.tokens[i].hidden = true;\n      i += 2;\n    }\n  }\n}\nexport default function list(state, startLine, endLine, silent) {\n  let max, pos, start, token;\n  let nextLine = startLine;\n  let tight = true;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 && state.sCount[nextLine] - state.listIndent >= 4 && state.sCount[nextLine] < state.blkIndent) {\n    return false;\n  }\n  let isTerminatingParagraph = false;\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      isTerminatingParagraph = true;\n    }\n  }\n\n  // Detect list type and position after marker\n  let isOrdered;\n  let markerValue;\n  let posAfterMarker;\n  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {\n    isOrdered = true;\n    start = state.bMarks[nextLine] + state.tShift[nextLine];\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1));\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false;\n  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false;\n  }\n\n  // For validation mode we can terminate immediately\n  if (silent) {\n    return true;\n  }\n\n  // We should terminate list on style change. Remember first one to compare.\n  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1);\n\n  // Start list\n  const listTokIdx = state.tokens.length;\n  if (isOrdered) {\n    token = state.push('ordered_list_open', 'ol', 1);\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]];\n    }\n  } else {\n    token = state.push('bullet_list_open', 'ul', 1);\n  }\n  const listLines = [nextLine, 0];\n  token.map = listLines;\n  token.markup = String.fromCharCode(markerCharCode);\n\n  //\n  // Iterate list items\n  //\n\n  let prevEmptyEnd = false;\n  const terminatorRules = state.md.block.ruler.getRules('list');\n  const oldParentType = state.parentType;\n  state.parentType = 'list';\n  while (nextLine < endLine) {\n    pos = posAfterMarker;\n    max = state.eMarks[nextLine];\n    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine]);\n    let offset = initial;\n    while (pos < max) {\n      const ch = state.src.charCodeAt(pos);\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4;\n      } else if (ch === 0x20) {\n        offset++;\n      } else {\n        break;\n      }\n      pos++;\n    }\n    const contentStart = pos;\n    let indentAfterMarker;\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = offset - initial;\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    const indent = initial + indentAfterMarker;\n\n    // Run subparser & write tokens\n    token = state.push('list_item_open', 'li', 1);\n    token.markup = String.fromCharCode(markerCharCode);\n    const itemLines = [nextLine, 0];\n    token.map = itemLines;\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1);\n    }\n\n    // change current state, then restore it after parser subcall\n    const oldTight = state.tight;\n    const oldTShift = state.tShift[nextLine];\n    const oldSCount = state.sCount[nextLine];\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    const oldListIndent = state.listIndent;\n    state.listIndent = state.blkIndent;\n    state.blkIndent = indent;\n    state.tight = true;\n    state.tShift[nextLine] = contentStart - state.bMarks[nextLine];\n    state.sCount[nextLine] = offset;\n    if (contentStart >= max && state.isEmpty(nextLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine);\n    } else {\n      state.md.block.tokenize(state, nextLine, endLine, true);\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = state.line - nextLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = state.listIndent;\n    state.listIndent = oldListIndent;\n    state.tShift[nextLine] = oldTShift;\n    state.sCount[nextLine] = oldSCount;\n    state.tight = oldTight;\n    token = state.push('list_item_close', 'li', -1);\n    token.markup = String.fromCharCode(markerCharCode);\n    nextLine = state.line;\n    itemLines[1] = nextLine;\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      break;\n    }\n\n    // fail if terminating block found\n    let terminate = false;\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1);\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1);\n  }\n  token.markup = String.fromCharCode(markerCharCode);\n  listLines[1] = nextLine;\n  state.line = nextLine;\n  state.parentType = oldParentType;\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n  return true;\n}","map":{"version":3,"names":["isSpace","skipBulletListMarker","state","startLine","max","eMarks","pos","bMarks","tShift","marker","src","charCodeAt","ch","skipOrderedListMarker","start","markTightParagraphs","idx","level","i","l","tokens","length","type","hidden","list","endLine","silent","token","nextLine","tight","sCount","blkIndent","listIndent","isTerminatingParagraph","parentType","isOrdered","markerValue","posAfterMarker","Number","slice","skipSpaces","markerCharCode","listTokIdx","push","attrs","listLines","map","markup","String","fromCharCode","prevEmptyEnd","terminatorRules","md","block","ruler","getRules","oldParentType","initial","offset","bsCount","contentStart","indentAfterMarker","indent","itemLines","info","oldTight","oldTShift","oldSCount","oldListIndent","isEmpty","line","Math","min","tokenize","terminate"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_block/list.mjs"],"sourcesContent":["// Lists\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Search `[-+*][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipBulletListMarker (state, startLine) {\n  const max = state.eMarks[startLine]\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n\n  const marker = state.src.charCodeAt(pos++)\n  // Check bullet\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x2B/* + */) {\n    return -1\n  }\n\n  if (pos < max) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (!isSpace(ch)) {\n      // \" -test \" - is not a list item\n      return -1\n    }\n  }\n\n  return pos\n}\n\n// Search `\\d+[.)][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\nfunction skipOrderedListMarker (state, startLine) {\n  const start = state.bMarks[startLine] + state.tShift[startLine]\n  const max = state.eMarks[startLine]\n  let pos = start\n\n  // List marker should have at least 2 chars (digit + dot)\n  if (pos + 1 >= max) { return -1 }\n\n  let ch = state.src.charCodeAt(pos++)\n\n  if (ch < 0x30/* 0 */ || ch > 0x39/* 9 */) { return -1 }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) { return -1 }\n\n    ch = state.src.charCodeAt(pos++)\n\n    if (ch >= 0x30/* 0 */ && ch <= 0x39/* 9 */) {\n      // List marker should have no more than 9 digits\n      // (prevents integer overflow in browsers)\n      if (pos - start >= 10) { return -1 }\n\n      continue\n    }\n\n    // found valid marker\n    if (ch === 0x29/* ) */ || ch === 0x2e/* . */) {\n      break\n    }\n\n    return -1\n  }\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos)\n\n    if (!isSpace(ch)) {\n      // \" 1.test \" - is not a list item\n      return -1\n    }\n  }\n  return pos\n}\n\nfunction markTightParagraphs (state, idx) {\n  const level = state.level + 2\n\n  for (let i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].hidden = true\n      state.tokens[i].hidden = true\n      i += 2\n    }\n  }\n}\n\nexport default function list (state, startLine, endLine, silent) {\n  let max, pos, start, token\n  let nextLine = startLine\n  let tight = true\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // Special case:\n  //  - item 1\n  //   - item 2\n  //    - item 3\n  //     - item 4\n  //      - this one is a paragraph continuation\n  if (state.listIndent >= 0 &&\n      state.sCount[nextLine] - state.listIndent >= 4 &&\n      state.sCount[nextLine] < state.blkIndent) {\n    return false\n  }\n\n  let isTerminatingParagraph = false\n\n  // limit conditions when list can interrupt\n  // a paragraph (validation mode only)\n  if (silent && state.parentType === 'paragraph') {\n    // Next list item should still terminate previous list item;\n    //\n    // This code can fail if plugins use blkIndent as well as lists,\n    // but I hope the spec gets fixed long before that happens.\n    //\n    if (state.sCount[nextLine] >= state.blkIndent) {\n      isTerminatingParagraph = true\n    }\n  }\n\n  // Detect list type and position after marker\n  let isOrdered\n  let markerValue\n  let posAfterMarker\n  if ((posAfterMarker = skipOrderedListMarker(state, nextLine)) >= 0) {\n    isOrdered = true\n    start = state.bMarks[nextLine] + state.tShift[nextLine]\n    markerValue = Number(state.src.slice(start, posAfterMarker - 1))\n\n    // If we're starting a new ordered list right after\n    // a paragraph, it should start with 1.\n    if (isTerminatingParagraph && markerValue !== 1) return false\n  } else if ((posAfterMarker = skipBulletListMarker(state, nextLine)) >= 0) {\n    isOrdered = false\n  } else {\n    return false\n  }\n\n  // If we're starting a new unordered list right after\n  // a paragraph, first line should not be empty.\n  if (isTerminatingParagraph) {\n    if (state.skipSpaces(posAfterMarker) >= state.eMarks[nextLine]) return false\n  }\n\n  // For validation mode we can terminate immediately\n  if (silent) { return true }\n\n  // We should terminate list on style change. Remember first one to compare.\n  const markerCharCode = state.src.charCodeAt(posAfterMarker - 1)\n\n  // Start list\n  const listTokIdx = state.tokens.length\n\n  if (isOrdered) {\n    token       = state.push('ordered_list_open', 'ol', 1)\n    if (markerValue !== 1) {\n      token.attrs = [['start', markerValue]]\n    }\n  } else {\n    token       = state.push('bullet_list_open', 'ul', 1)\n  }\n\n  const listLines = [nextLine, 0]\n  token.map    = listLines\n  token.markup = String.fromCharCode(markerCharCode)\n\n  //\n  // Iterate list items\n  //\n\n  let prevEmptyEnd = false\n  const terminatorRules = state.md.block.ruler.getRules('list')\n\n  const oldParentType = state.parentType\n  state.parentType = 'list'\n\n  while (nextLine < endLine) {\n    pos = posAfterMarker\n    max = state.eMarks[nextLine]\n\n    const initial = state.sCount[nextLine] + posAfterMarker - (state.bMarks[nextLine] + state.tShift[nextLine])\n    let offset = initial\n\n    while (pos < max) {\n      const ch = state.src.charCodeAt(pos)\n\n      if (ch === 0x09) {\n        offset += 4 - (offset + state.bsCount[nextLine]) % 4\n      } else if (ch === 0x20) {\n        offset++\n      } else {\n        break\n      }\n\n      pos++\n    }\n\n    const contentStart = pos\n    let indentAfterMarker\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1\n    } else {\n      indentAfterMarker = offset - initial\n    }\n\n    // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n    if (indentAfterMarker > 4) { indentAfterMarker = 1 }\n\n    // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n    const indent = initial + indentAfterMarker\n\n    // Run subparser & write tokens\n    token        = state.push('list_item_open', 'li', 1)\n    token.markup = String.fromCharCode(markerCharCode)\n    const itemLines = [nextLine, 0]\n    token.map    = itemLines\n    if (isOrdered) {\n      token.info = state.src.slice(start, posAfterMarker - 1)\n    }\n\n    // change current state, then restore it after parser subcall\n    const oldTight = state.tight\n    const oldTShift = state.tShift[nextLine]\n    const oldSCount = state.sCount[nextLine]\n\n    //  - example list\n    // ^ listIndent position will be here\n    //   ^ blkIndent position will be here\n    //\n    const oldListIndent = state.listIndent\n    state.listIndent = state.blkIndent\n    state.blkIndent = indent\n\n    state.tight = true\n    state.tShift[nextLine] = contentStart - state.bMarks[nextLine]\n    state.sCount[nextLine] = offset\n\n    if (contentStart >= max && state.isEmpty(nextLine + 1)) {\n      // workaround for this case\n      // (list item is empty, list terminates before \"foo\"):\n      // ~~~~~~~~\n      //   -\n      //\n      //     foo\n      // ~~~~~~~~\n      state.line = Math.min(state.line + 2, endLine)\n    } else {\n      state.md.block.tokenize(state, nextLine, endLine, true)\n    }\n\n    // If any of list item is tight, mark list as tight\n    if (!state.tight || prevEmptyEnd) {\n      tight = false\n    }\n    // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n    prevEmptyEnd = (state.line - nextLine) > 1 && state.isEmpty(state.line - 1)\n\n    state.blkIndent = state.listIndent\n    state.listIndent = oldListIndent\n    state.tShift[nextLine] = oldTShift\n    state.sCount[nextLine] = oldSCount\n    state.tight = oldTight\n\n    token        = state.push('list_item_close', 'li', -1)\n    token.markup = String.fromCharCode(markerCharCode)\n\n    nextLine = state.line\n    itemLines[1] = nextLine\n\n    if (nextLine >= endLine) { break }\n\n    //\n    // Try to check if list is terminated or continued.\n    //\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    // if it's indented more than 3 spaces, it should be a code block\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n\n    // fail if terminating block found\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n\n    // fail if list has another type\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n      start = state.bMarks[nextLine] + state.tShift[nextLine]\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine)\n      if (posAfterMarker < 0) { break }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) { break }\n  }\n\n  // Finalize list\n  if (isOrdered) {\n    token = state.push('ordered_list_close', 'ol', -1)\n  } else {\n    token = state.push('bullet_list_close', 'ul', -1)\n  }\n  token.markup = String.fromCharCode(markerCharCode)\n\n  listLines[1] = nextLine\n  state.line = nextLine\n\n  state.parentType = oldParentType\n\n  // mark paragraphs tight if needed\n  if (tight) {\n    markTightParagraphs(state, listTokIdx)\n  }\n\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}