{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n\nimport { assign, unescapeAll, escapeHtml } from './common/utils.mjs';\nconst default_rules = {};\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx];\n  return '<code' + slf.renderAttrs(token) + '>' + escapeHtml(token.content) + '</code>';\n};\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx];\n  return '<pre' + slf.renderAttrs(token) + '><code>' + escapeHtml(tokens[idx].content) + '</code></pre>\\n';\n};\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx];\n  const info = token.info ? unescapeAll(token.info).trim() : '';\n  let langName = '';\n  let langAttrs = '';\n  if (info) {\n    const arr = info.split(/(\\s+)/g);\n    langName = arr[0];\n    langAttrs = arr.slice(2).join('');\n  }\n  let highlighted;\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n';\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .deepClone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    const i = token.attrIndex('class');\n    const tmpAttrs = token.attrs ? token.attrs.slice() : [];\n    if (i < 0) {\n      tmpAttrs.push(['class', options.langPrefix + langName]);\n    } else {\n      tmpAttrs[i] = tmpAttrs[i].slice();\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName;\n    }\n\n    // Fake token just to render attributes\n    const tmpToken = {\n      attrs: tmpAttrs\n    };\n    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>\\n`;\n  }\n  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>\\n`;\n};\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx];\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] = slf.renderInlineAsText(token.children, options, env);\n  return slf.renderToken(tokens, idx, options);\n};\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n};\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content);\n};\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content;\n};\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer() {\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.mjs)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules);\n}\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs(token) {\n  let i, l, result;\n  if (!token.attrs) {\n    return '';\n  }\n  result = '';\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"';\n  }\n  return result;\n};\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken(tokens, idx, options) {\n  const token = tokens[idx];\n  let result = '';\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return '';\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n';\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag;\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token);\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /';\n  }\n\n  // Check if we need to add a newline after this tag\n  let needLf = false;\n  if (token.block) {\n    needLf = true;\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        const nextToken = tokens[idx + 1];\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false;\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false;\n        }\n      }\n    }\n  }\n  result += needLf ? '>\\n' : '>';\n  return result;\n};\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  let result = '';\n  const rules = this.rules;\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type;\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options);\n    }\n  }\n  return result;\n};\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  let result = '';\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    switch (tokens[i].type) {\n      case 'text':\n        result += tokens[i].content;\n        break;\n      case 'image':\n        result += this.renderInlineAsText(tokens[i].children, options, env);\n        break;\n      case 'html_inline':\n      case 'html_block':\n        result += tokens[i].content;\n        break;\n      case 'softbreak':\n      case 'hardbreak':\n        result += '\\n';\n        break;\n      default:\n      // all other tokens are skipped\n    }\n  }\n  return result;\n};\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  let result = '';\n  const rules = this.rules;\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type;\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this);\n    } else {\n      result += this.renderToken(tokens, i, options, env);\n    }\n  }\n  return result;\n};\nexport default Renderer;","map":{"version":3,"names":["assign","unescapeAll","escapeHtml","default_rules","code_inline","tokens","idx","options","env","slf","token","renderAttrs","content","code_block","fence","info","trim","langName","langAttrs","arr","split","slice","join","highlighted","highlight","indexOf","i","attrIndex","tmpAttrs","attrs","push","langPrefix","tmpToken","image","renderInlineAsText","children","renderToken","hardbreak","xhtmlOut","softbreak","breaks","text","html_block","html_inline","Renderer","rules","prototype","l","result","length","hidden","block","nesting","tag","needLf","nextToken","type","renderInline","len","render"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/renderer.mjs"],"sourcesContent":["/**\n * class Renderer\n *\n * Generates HTML from parsed token stream. Each instance has independent\n * copy of rules. Those can be rewritten with ease. Also, you can add new\n * rules if you create plugin and adds new token types.\n **/\n\nimport { assign, unescapeAll, escapeHtml } from './common/utils.mjs'\n\nconst default_rules = {}\n\ndefault_rules.code_inline = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  return  '<code' + slf.renderAttrs(token) + '>' +\n          escapeHtml(token.content) +\n          '</code>'\n}\n\ndefault_rules.code_block = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  return  '<pre' + slf.renderAttrs(token) + '><code>' +\n          escapeHtml(tokens[idx].content) +\n          '</code></pre>\\n'\n}\n\ndefault_rules.fence = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n  const info = token.info ? unescapeAll(token.info).trim() : ''\n  let langName = ''\n  let langAttrs = ''\n\n  if (info) {\n    const arr = info.split(/(\\s+)/g)\n    langName = arr[0]\n    langAttrs = arr.slice(2).join('')\n  }\n\n  let highlighted\n  if (options.highlight) {\n    highlighted = options.highlight(token.content, langName, langAttrs) || escapeHtml(token.content)\n  } else {\n    highlighted = escapeHtml(token.content)\n  }\n\n  if (highlighted.indexOf('<pre') === 0) {\n    return highlighted + '\\n'\n  }\n\n  // If language exists, inject class gently, without modifying original token.\n  // May be, one day we will add .deepClone() for token and simplify this part, but\n  // now we prefer to keep things local.\n  if (info) {\n    const i = token.attrIndex('class')\n    const tmpAttrs = token.attrs ? token.attrs.slice() : []\n\n    if (i < 0) {\n      tmpAttrs.push(['class', options.langPrefix + langName])\n    } else {\n      tmpAttrs[i] = tmpAttrs[i].slice()\n      tmpAttrs[i][1] += ' ' + options.langPrefix + langName\n    }\n\n    // Fake token just to render attributes\n    const tmpToken = {\n      attrs: tmpAttrs\n    }\n\n    return `<pre><code${slf.renderAttrs(tmpToken)}>${highlighted}</code></pre>\\n`\n  }\n\n  return `<pre><code${slf.renderAttrs(token)}>${highlighted}</code></pre>\\n`\n}\n\ndefault_rules.image = function (tokens, idx, options, env, slf) {\n  const token = tokens[idx]\n\n  // \"alt\" attr MUST be set, even if empty. Because it's mandatory and\n  // should be placed on proper position for tests.\n  //\n  // Replace content with actual value\n\n  token.attrs[token.attrIndex('alt')][1] =\n    slf.renderInlineAsText(token.children, options, env)\n\n  return slf.renderToken(tokens, idx, options)\n}\n\ndefault_rules.hardbreak = function (tokens, idx, options /*, env */) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n'\n}\ndefault_rules.softbreak = function (tokens, idx, options /*, env */) {\n  return options.breaks ? (options.xhtmlOut ? '<br />\\n' : '<br>\\n') : '\\n'\n}\n\ndefault_rules.text = function (tokens, idx /*, options, env */) {\n  return escapeHtml(tokens[idx].content)\n}\n\ndefault_rules.html_block = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content\n}\ndefault_rules.html_inline = function (tokens, idx /*, options, env */) {\n  return tokens[idx].content\n}\n\n/**\n * new Renderer()\n *\n * Creates new [[Renderer]] instance and fill [[Renderer#rules]] with defaults.\n **/\nfunction Renderer () {\n  /**\n   * Renderer#rules -> Object\n   *\n   * Contains render rules for tokens. Can be updated and extended.\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * var md = require('markdown-it')();\n   *\n   * md.renderer.rules.strong_open  = function () { return '<b>'; };\n   * md.renderer.rules.strong_close = function () { return '</b>'; };\n   *\n   * var result = md.renderInline(...);\n   * ```\n   *\n   * Each rule is called as independent static function with fixed signature:\n   *\n   * ```javascript\n   * function my_token_render(tokens, idx, options, env, renderer) {\n   *   // ...\n   *   return renderedHTML;\n   * }\n   * ```\n   *\n   * See [source code](https://github.com/markdown-it/markdown-it/blob/master/lib/renderer.mjs)\n   * for more details and examples.\n   **/\n  this.rules = assign({}, default_rules)\n}\n\n/**\n * Renderer.renderAttrs(token) -> String\n *\n * Render token attributes to string.\n **/\nRenderer.prototype.renderAttrs = function renderAttrs (token) {\n  let i, l, result\n\n  if (!token.attrs) { return '' }\n\n  result = ''\n\n  for (i = 0, l = token.attrs.length; i < l; i++) {\n    result += ' ' + escapeHtml(token.attrs[i][0]) + '=\"' + escapeHtml(token.attrs[i][1]) + '\"'\n  }\n\n  return result\n}\n\n/**\n * Renderer.renderToken(tokens, idx, options) -> String\n * - tokens (Array): list of tokens\n * - idx (Numbed): token index to render\n * - options (Object): params of parser instance\n *\n * Default token renderer. Can be overriden by custom function\n * in [[Renderer#rules]].\n **/\nRenderer.prototype.renderToken = function renderToken (tokens, idx, options) {\n  const token = tokens[idx]\n  let result = ''\n\n  // Tight list paragraphs\n  if (token.hidden) {\n    return ''\n  }\n\n  // Insert a newline between hidden paragraph and subsequent opening\n  // block-level tag.\n  //\n  // For example, here we should insert a newline before blockquote:\n  //  - a\n  //    >\n  //\n  if (token.block && token.nesting !== -1 && idx && tokens[idx - 1].hidden) {\n    result += '\\n'\n  }\n\n  // Add token name, e.g. `<img`\n  result += (token.nesting === -1 ? '</' : '<') + token.tag\n\n  // Encode attributes, e.g. `<img src=\"foo\"`\n  result += this.renderAttrs(token)\n\n  // Add a slash for self-closing tags, e.g. `<img src=\"foo\" /`\n  if (token.nesting === 0 && options.xhtmlOut) {\n    result += ' /'\n  }\n\n  // Check if we need to add a newline after this tag\n  let needLf = false\n  if (token.block) {\n    needLf = true\n\n    if (token.nesting === 1) {\n      if (idx + 1 < tokens.length) {\n        const nextToken = tokens[idx + 1]\n\n        if (nextToken.type === 'inline' || nextToken.hidden) {\n          // Block-level tag containing an inline tag.\n          //\n          needLf = false\n        } else if (nextToken.nesting === -1 && nextToken.tag === token.tag) {\n          // Opening tag + closing tag of the same type. E.g. `<li></li>`.\n          //\n          needLf = false\n        }\n      }\n    }\n  }\n\n  result += needLf ? '>\\n' : '>'\n\n  return result\n}\n\n/**\n * Renderer.renderInline(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * The same as [[Renderer.render]], but for single token of `inline` type.\n **/\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  let result = ''\n  const rules = this.rules\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type\n\n    if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this)\n    } else {\n      result += this.renderToken(tokens, i, options)\n    }\n  }\n\n  return result\n}\n\n/** internal\n * Renderer.renderInlineAsText(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Special kludge for image `alt` attributes to conform CommonMark spec.\n * Don't try to use it! Spec requires to show `alt` content with stripped markup,\n * instead of simple escaping.\n **/\nRenderer.prototype.renderInlineAsText = function (tokens, options, env) {\n  let result = ''\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    switch (tokens[i].type) {\n      case 'text':\n        result += tokens[i].content\n        break\n      case 'image':\n        result += this.renderInlineAsText(tokens[i].children, options, env)\n        break\n      case 'html_inline':\n      case 'html_block':\n        result += tokens[i].content\n        break\n      case 'softbreak':\n      case 'hardbreak':\n        result += '\\n'\n        break\n      default:\n        // all other tokens are skipped\n    }\n  }\n\n  return result\n}\n\n/**\n * Renderer.render(tokens, options, env) -> String\n * - tokens (Array): list on block tokens to render\n * - options (Object): params of parser instance\n * - env (Object): additional data from parsed input (references, for example)\n *\n * Takes token stream and generates HTML. Probably, you will never need to call\n * this method directly.\n **/\nRenderer.prototype.render = function (tokens, options, env) {\n  let result = ''\n  const rules = this.rules\n\n  for (let i = 0, len = tokens.length; i < len; i++) {\n    const type = tokens[i].type\n\n    if (type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env)\n    } else if (typeof rules[type] !== 'undefined') {\n      result += rules[type](tokens, i, options, env, this)\n    } else {\n      result += this.renderToken(tokens, i, options, env)\n    }\n  }\n\n  return result\n}\n\nexport default Renderer\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}