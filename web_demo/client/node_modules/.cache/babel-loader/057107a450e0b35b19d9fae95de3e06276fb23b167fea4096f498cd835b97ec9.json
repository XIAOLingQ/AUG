{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Process [link](<to> \"stuff\")\n\nimport { normalizeReference, isSpace } from '../common/utils.mjs';\nexport default function link(state, silent) {\n  let code, label, res, ref;\n  let href = '';\n  let title = '';\n  let start = state.pos;\n  let parseReference = true;\n  if (state.src.charCodeAt(state.pos) !== 0x5B /* [ */) {\n    return false;\n  }\n  const oldPos = state.pos;\n  const max = state.posMax;\n  const labelStart = state.pos + 1;\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true);\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) {\n    return false;\n  }\n  let pos = labelEnd + 1;\n  if (pos < max && state.src.charCodeAt(pos) === 0x28 /* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false;\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++;\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n      if (!isSpace(code) && code !== 0x0A) {\n        break;\n      }\n    }\n    if (pos >= max) {\n      return false;\n    }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos;\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax);\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str);\n      if (state.md.validateLink(href)) {\n        pos = res.pos;\n      } else {\n        href = '';\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n      start = pos;\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n        if (!isSpace(code) && code !== 0x0A) {\n          break;\n        }\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax);\n      if (pos < max && start !== pos && res.ok) {\n        title = res.str;\n        pos = res.pos;\n\n        // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n          if (!isSpace(code) && code !== 0x0A) {\n            break;\n          }\n        }\n      }\n    }\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29 /* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true;\n    }\n    pos++;\n  }\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') {\n      return false;\n    }\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B /* [ */) {\n      start = pos + 1;\n      pos = state.md.helpers.parseLinkLabel(state, pos);\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++);\n      } else {\n        pos = labelEnd + 1;\n      }\n    } else {\n      pos = labelEnd + 1;\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) {\n      label = state.src.slice(labelStart, labelEnd);\n    }\n    ref = state.env.references[normalizeReference(label)];\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n    href = ref.href;\n    title = ref.title;\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n    const token_o = state.push('link_open', 'a', 1);\n    const attrs = [['href', href]];\n    token_o.attrs = attrs;\n    if (title) {\n      attrs.push(['title', title]);\n    }\n    state.linkLevel++;\n    state.md.inline.tokenize(state);\n    state.linkLevel--;\n    state.push('link_close', 'a', -1);\n  }\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n}","map":{"version":3,"names":["normalizeReference","isSpace","link","state","silent","code","label","res","ref","href","title","start","pos","parseReference","src","charCodeAt","oldPos","max","posMax","labelStart","labelEnd","md","helpers","parseLinkLabel","parseLinkDestination","ok","normalizeLink","str","validateLink","parseLinkTitle","env","references","slice","token_o","push","attrs","linkLevel","inline","tokenize"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_inline/link.mjs"],"sourcesContent":["// Process [link](<to> \"stuff\")\n\nimport { normalizeReference, isSpace } from '../common/utils.mjs'\n\nexport default function link (state, silent) {\n  let code, label, res, ref\n  let href = ''\n  let title = ''\n  let start = state.pos\n  let parseReference = true\n\n  if (state.src.charCodeAt(state.pos) !== 0x5B/* [ */) { return false }\n\n  const oldPos = state.pos\n  const max = state.posMax\n  const labelStart = state.pos + 1\n  const labelEnd = state.md.helpers.parseLinkLabel(state, state.pos, true)\n\n  // parser failed to find ']', so it's not a valid link\n  if (labelEnd < 0) { return false }\n\n  let pos = labelEnd + 1\n  if (pos < max && state.src.charCodeAt(pos) === 0x28/* ( */) {\n    //\n    // Inline link\n    //\n\n    // might have found a valid shortcut link, disable reference parsing\n    parseReference = false\n\n    // [link](  <href>  \"title\"  )\n    //        ^^ skipping these spaces\n    pos++\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos)\n      if (!isSpace(code) && code !== 0x0A) { break }\n    }\n    if (pos >= max) { return false }\n\n    // [link](  <href>  \"title\"  )\n    //          ^^^^^^ parsing link destination\n    start = pos\n    res = state.md.helpers.parseLinkDestination(state.src, pos, state.posMax)\n    if (res.ok) {\n      href = state.md.normalizeLink(res.str)\n      if (state.md.validateLink(href)) {\n        pos = res.pos\n      } else {\n        href = ''\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n      start = pos\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos)\n        if (!isSpace(code) && code !== 0x0A) { break }\n      }\n\n      // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n      res = state.md.helpers.parseLinkTitle(state.src, pos, state.posMax)\n      if (pos < max && start !== pos && res.ok) {\n        title = res.str\n        pos = res.pos\n\n        // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos)\n          if (!isSpace(code) && code !== 0x0A) { break }\n        }\n      }\n    }\n\n    if (pos >= max || state.src.charCodeAt(pos) !== 0x29/* ) */) {\n      // parsing a valid shortcut link failed, fallback to reference\n      parseReference = true\n    }\n    pos++\n  }\n\n  if (parseReference) {\n    //\n    // Link reference\n    //\n    if (typeof state.env.references === 'undefined') { return false }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B/* [ */) {\n      start = pos + 1\n      pos = state.md.helpers.parseLinkLabel(state, pos)\n      if (pos >= 0) {\n        label = state.src.slice(start, pos++)\n      } else {\n        pos = labelEnd + 1\n      }\n    } else {\n      pos = labelEnd + 1\n    }\n\n    // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n    if (!label) { label = state.src.slice(labelStart, labelEnd) }\n\n    ref = state.env.references[normalizeReference(label)]\n    if (!ref) {\n      state.pos = oldPos\n      return false\n    }\n    href = ref.href\n    title = ref.title\n  }\n\n  //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n  if (!silent) {\n    state.pos = labelStart\n    state.posMax = labelEnd\n\n    const token_o = state.push('link_open', 'a', 1)\n    const attrs = [['href', href]]\n    token_o.attrs  = attrs\n    if (title) {\n      attrs.push(['title', title])\n    }\n\n    state.linkLevel++\n    state.md.inline.tokenize(state)\n    state.linkLevel--\n\n    state.push('link_close', 'a', -1)\n  }\n\n  state.pos = pos\n  state.posMax = max\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}