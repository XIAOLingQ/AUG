{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Parse backticks\n\nexport default function backtick(state, silent) {\n  let pos = state.pos;\n  const ch = state.src.charCodeAt(pos);\n  if (ch !== 0x60 /* ` */) {\n    return false;\n  }\n  const start = pos;\n  pos++;\n  const max = state.posMax;\n\n  // scan marker length\n  while (pos < max && state.src.charCodeAt(pos) === 0x60 /* ` */) {\n    pos++;\n  }\n  const marker = state.src.slice(start, pos);\n  const openerLength = marker.length;\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker;\n    state.pos += openerLength;\n    return true;\n  }\n  let matchEnd = pos;\n  let matchStart;\n\n  // Nothing found in the cache, scan until the end of the line (or until marker is found)\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    // scan marker length\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60 /* ` */) {\n      matchEnd++;\n    }\n    const closerLength = matchEnd - matchStart;\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        const token = state.push('code_inline', 'code', 0);\n        token.markup = marker;\n        token.content = state.src.slice(pos, matchStart).replace(/\\n/g, ' ').replace(/^ (.+) $/, '$1');\n      }\n      state.pos = matchEnd;\n      return true;\n    }\n\n    // Some different length found, put it in cache as upper limit of where closer can be found\n    state.backticks[closerLength] = matchStart;\n  }\n\n  // Scanned through the end, didn't find anything\n  state.backticksScanned = true;\n  if (!silent) state.pending += marker;\n  state.pos += openerLength;\n  return true;\n}","map":{"version":3,"names":["backtick","state","silent","pos","ch","src","charCodeAt","start","max","posMax","marker","slice","openerLength","length","backticksScanned","backticks","pending","matchEnd","matchStart","indexOf","closerLength","token","push","markup","content","replace"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_inline/backticks.mjs"],"sourcesContent":["// Parse backticks\n\nexport default function backtick (state, silent) {\n  let pos = state.pos\n  const ch = state.src.charCodeAt(pos)\n\n  if (ch !== 0x60/* ` */) { return false }\n\n  const start = pos\n  pos++\n  const max = state.posMax\n\n  // scan marker length\n  while (pos < max && state.src.charCodeAt(pos) === 0x60/* ` */) { pos++ }\n\n  const marker = state.src.slice(start, pos)\n  const openerLength = marker.length\n\n  if (state.backticksScanned && (state.backticks[openerLength] || 0) <= start) {\n    if (!silent) state.pending += marker\n    state.pos += openerLength\n    return true\n  }\n\n  let matchEnd = pos\n  let matchStart\n\n  // Nothing found in the cache, scan until the end of the line (or until marker is found)\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1\n\n    // scan marker length\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60/* ` */) { matchEnd++ }\n\n    const closerLength = matchEnd - matchStart\n\n    if (closerLength === openerLength) {\n      // Found matching closer length.\n      if (!silent) {\n        const token = state.push('code_inline', 'code', 0)\n        token.markup = marker\n        token.content = state.src.slice(pos, matchStart)\n          .replace(/\\n/g, ' ')\n          .replace(/^ (.+) $/, '$1')\n      }\n      state.pos = matchEnd\n      return true\n    }\n\n    // Some different length found, put it in cache as upper limit of where closer can be found\n    state.backticks[closerLength] = matchStart\n  }\n\n  // Scanned through the end, didn't find anything\n  state.backticksScanned = true\n\n  if (!silent) state.pending += marker\n  state.pos += openerLength\n  return true\n}\n"],"mappings":";AAAA;;AAEA,eAAe,SAASA,QAAQA,CAAEC,KAAK,EAAEC,MAAM,EAAE;EAC/C,IAAIC,GAAG,GAAGF,KAAK,CAACE,GAAG;EACnB,MAAMC,EAAE,GAAGH,KAAK,CAACI,GAAG,CAACC,UAAU,CAACH,GAAG,CAAC;EAEpC,IAAIC,EAAE,KAAK,IAAI,UAAS;IAAE,OAAO,KAAK;EAAC;EAEvC,MAAMG,KAAK,GAAGJ,GAAG;EACjBA,GAAG,EAAE;EACL,MAAMK,GAAG,GAAGP,KAAK,CAACQ,MAAM;;EAExB;EACA,OAAON,GAAG,GAAGK,GAAG,IAAIP,KAAK,CAACI,GAAG,CAACC,UAAU,CAACH,GAAG,CAAC,KAAK,IAAI,UAAS;IAAEA,GAAG,EAAE;EAAC;EAEvE,MAAMO,MAAM,GAAGT,KAAK,CAACI,GAAG,CAACM,KAAK,CAACJ,KAAK,EAAEJ,GAAG,CAAC;EAC1C,MAAMS,YAAY,GAAGF,MAAM,CAACG,MAAM;EAElC,IAAIZ,KAAK,CAACa,gBAAgB,IAAI,CAACb,KAAK,CAACc,SAAS,CAACH,YAAY,CAAC,IAAI,CAAC,KAAKL,KAAK,EAAE;IAC3E,IAAI,CAACL,MAAM,EAAED,KAAK,CAACe,OAAO,IAAIN,MAAM;IACpCT,KAAK,CAACE,GAAG,IAAIS,YAAY;IACzB,OAAO,IAAI;EACb;EAEA,IAAIK,QAAQ,GAAGd,GAAG;EAClB,IAAIe,UAAU;;EAEd;EACA,OAAO,CAACA,UAAU,GAAGjB,KAAK,CAACI,GAAG,CAACc,OAAO,CAAC,GAAG,EAAEF,QAAQ,CAAC,MAAM,CAAC,CAAC,EAAE;IAC7DA,QAAQ,GAAGC,UAAU,GAAG,CAAC;;IAEzB;IACA,OAAOD,QAAQ,GAAGT,GAAG,IAAIP,KAAK,CAACI,GAAG,CAACC,UAAU,CAACW,QAAQ,CAAC,KAAK,IAAI,UAAS;MAAEA,QAAQ,EAAE;IAAC;IAEtF,MAAMG,YAAY,GAAGH,QAAQ,GAAGC,UAAU;IAE1C,IAAIE,YAAY,KAAKR,YAAY,EAAE;MACjC;MACA,IAAI,CAACV,MAAM,EAAE;QACX,MAAMmB,KAAK,GAAGpB,KAAK,CAACqB,IAAI,CAAC,aAAa,EAAE,MAAM,EAAE,CAAC,CAAC;QAClDD,KAAK,CAACE,MAAM,GAAGb,MAAM;QACrBW,KAAK,CAACG,OAAO,GAAGvB,KAAK,CAACI,GAAG,CAACM,KAAK,CAACR,GAAG,EAAEe,UAAU,CAAC,CAC7CO,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,CACnBA,OAAO,CAAC,UAAU,EAAE,IAAI,CAAC;MAC9B;MACAxB,KAAK,CAACE,GAAG,GAAGc,QAAQ;MACpB,OAAO,IAAI;IACb;;IAEA;IACAhB,KAAK,CAACc,SAAS,CAACK,YAAY,CAAC,GAAGF,UAAU;EAC5C;;EAEA;EACAjB,KAAK,CAACa,gBAAgB,GAAG,IAAI;EAE7B,IAAI,CAACZ,MAAM,EAAED,KAAK,CAACe,OAAO,IAAIN,MAAM;EACpCT,KAAK,CAACE,GAAG,IAAIS,YAAY;EACzB,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}