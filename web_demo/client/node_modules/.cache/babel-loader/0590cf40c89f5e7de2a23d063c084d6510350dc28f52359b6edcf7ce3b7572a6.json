{"ast":null,"code":"// Join raw text tokens with the rest of the text\n//\n// This is set as a separate rule to provide an opportunity for plugins\n// to run text replacements after text join, but before escape join.\n//\n// For example, `\\:)` shouldn't be replaced with an emoji.\n//\n\nexport default function text_join(state) {\n  let curr, last;\n  const blockTokens = state.tokens;\n  const l = blockTokens.length;\n  for (let j = 0; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') continue;\n    const tokens = blockTokens[j].children;\n    const max = tokens.length;\n    for (curr = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text_special') {\n        tokens[curr].type = 'text';\n      }\n    }\n    for (curr = last = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text' && curr + 1 < max && tokens[curr + 1].type === 'text') {\n        // collapse two adjacent text nodes\n        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content;\n      } else {\n        if (curr !== last) {\n          tokens[last] = tokens[curr];\n        }\n        last++;\n      }\n    }\n    if (curr !== last) {\n      tokens.length = last;\n    }\n  }\n}","map":{"version":3,"names":["text_join","state","curr","last","blockTokens","tokens","l","length","j","type","children","max","content"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_core/text_join.mjs"],"sourcesContent":["// Join raw text tokens with the rest of the text\n//\n// This is set as a separate rule to provide an opportunity for plugins\n// to run text replacements after text join, but before escape join.\n//\n// For example, `\\:)` shouldn't be replaced with an emoji.\n//\n\nexport default function text_join (state) {\n  let curr, last\n  const blockTokens = state.tokens\n  const l = blockTokens.length\n\n  for (let j = 0; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') continue\n\n    const tokens = blockTokens[j].children\n    const max = tokens.length\n\n    for (curr = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text_special') {\n        tokens[curr].type = 'text'\n      }\n    }\n\n    for (curr = last = 0; curr < max; curr++) {\n      if (tokens[curr].type === 'text' &&\n          curr + 1 < max &&\n          tokens[curr + 1].type === 'text') {\n        // collapse two adjacent text nodes\n        tokens[curr + 1].content = tokens[curr].content + tokens[curr + 1].content\n      } else {\n        if (curr !== last) { tokens[last] = tokens[curr] }\n\n        last++\n      }\n    }\n\n    if (curr !== last) {\n      tokens.length = last\n    }\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAe,SAASA,SAASA,CAAEC,KAAK,EAAE;EACxC,IAAIC,IAAI,EAAEC,IAAI;EACd,MAAMC,WAAW,GAAGH,KAAK,CAACI,MAAM;EAChC,MAAMC,CAAC,GAAGF,WAAW,CAACG,MAAM;EAE5B,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,CAAC,EAAEE,CAAC,EAAE,EAAE;IAC1B,IAAIJ,WAAW,CAACI,CAAC,CAAC,CAACC,IAAI,KAAK,QAAQ,EAAE;IAEtC,MAAMJ,MAAM,GAAGD,WAAW,CAACI,CAAC,CAAC,CAACE,QAAQ;IACtC,MAAMC,GAAG,GAAGN,MAAM,CAACE,MAAM;IAEzB,KAAKL,IAAI,GAAG,CAAC,EAAEA,IAAI,GAAGS,GAAG,EAAET,IAAI,EAAE,EAAE;MACjC,IAAIG,MAAM,CAACH,IAAI,CAAC,CAACO,IAAI,KAAK,cAAc,EAAE;QACxCJ,MAAM,CAACH,IAAI,CAAC,CAACO,IAAI,GAAG,MAAM;MAC5B;IACF;IAEA,KAAKP,IAAI,GAAGC,IAAI,GAAG,CAAC,EAAED,IAAI,GAAGS,GAAG,EAAET,IAAI,EAAE,EAAE;MACxC,IAAIG,MAAM,CAACH,IAAI,CAAC,CAACO,IAAI,KAAK,MAAM,IAC5BP,IAAI,GAAG,CAAC,GAAGS,GAAG,IACdN,MAAM,CAACH,IAAI,GAAG,CAAC,CAAC,CAACO,IAAI,KAAK,MAAM,EAAE;QACpC;QACAJ,MAAM,CAACH,IAAI,GAAG,CAAC,CAAC,CAACU,OAAO,GAAGP,MAAM,CAACH,IAAI,CAAC,CAACU,OAAO,GAAGP,MAAM,CAACH,IAAI,GAAG,CAAC,CAAC,CAACU,OAAO;MAC5E,CAAC,MAAM;QACL,IAAIV,IAAI,KAAKC,IAAI,EAAE;UAAEE,MAAM,CAACF,IAAI,CAAC,GAAGE,MAAM,CAACH,IAAI,CAAC;QAAC;QAEjDC,IAAI,EAAE;MACR;IACF;IAEA,IAAID,IAAI,KAAKC,IAAI,EAAE;MACjBE,MAAM,CAACE,MAAM,GAAGJ,IAAI;IACtB;EACF;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}