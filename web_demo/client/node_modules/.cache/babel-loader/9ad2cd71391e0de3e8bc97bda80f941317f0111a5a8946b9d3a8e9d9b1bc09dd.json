{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Paragraph\n\nexport default function paragraph(state, startLine, endLine) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph');\n  const oldParentType = state.parentType;\n  let nextLine = startLine + 1;\n  state.parentType = 'paragraph';\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      continue;\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) {\n      continue;\n    }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false;\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n  }\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n  const token_o = state.push('paragraph_open', 'p', 1);\n  token_o.map = [startLine, state.line];\n  const token_i = state.push('inline', '', 0);\n  token_i.content = content;\n  token_i.map = [startLine, state.line];\n  token_i.children = [];\n  state.push('paragraph_close', 'p', -1);\n  state.parentType = oldParentType;\n  return true;\n}","map":{"version":3,"names":["paragraph","state","startLine","endLine","terminatorRules","md","block","ruler","getRules","oldParentType","parentType","nextLine","isEmpty","sCount","blkIndent","terminate","i","l","length","content","getLines","trim","line","token_o","push","map","token_i","children"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_block/paragraph.mjs"],"sourcesContent":["// Paragraph\n\nexport default function paragraph (state, startLine, endLine) {\n  const terminatorRules = state.md.block.ruler.getRules('paragraph')\n  const oldParentType = state.parentType\n  let nextLine = startLine + 1\n  state.parentType = 'paragraph'\n\n  // jump line-by-line until empty one or EOF\n  for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { continue }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { continue }\n\n    // Some tags can terminate paragraph without empty line.\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n    if (terminate) { break }\n  }\n\n  const content = state.getLines(startLine, nextLine, state.blkIndent, false).trim()\n\n  state.line = nextLine\n\n  const token_o    = state.push('paragraph_open', 'p', 1)\n  token_o.map      = [startLine, state.line]\n\n  const token_i    = state.push('inline', '', 0)\n  token_i.content  = content\n  token_i.map      = [startLine, state.line]\n  token_i.children = []\n\n  state.push('paragraph_close', 'p', -1)\n\n  state.parentType = oldParentType\n\n  return true\n}\n"],"mappings":";AAAA;;AAEA,eAAe,SAASA,SAASA,CAAEC,KAAK,EAAEC,SAAS,EAAEC,OAAO,EAAE;EAC5D,MAAMC,eAAe,GAAGH,KAAK,CAACI,EAAE,CAACC,KAAK,CAACC,KAAK,CAACC,QAAQ,CAAC,WAAW,CAAC;EAClE,MAAMC,aAAa,GAAGR,KAAK,CAACS,UAAU;EACtC,IAAIC,QAAQ,GAAGT,SAAS,GAAG,CAAC;EAC5BD,KAAK,CAACS,UAAU,GAAG,WAAW;;EAE9B;EACA,OAAOC,QAAQ,GAAGR,OAAO,IAAI,CAACF,KAAK,CAACW,OAAO,CAACD,QAAQ,CAAC,EAAEA,QAAQ,EAAE,EAAE;IACjE;IACA;IACA,IAAIV,KAAK,CAACY,MAAM,CAACF,QAAQ,CAAC,GAAGV,KAAK,CAACa,SAAS,GAAG,CAAC,EAAE;MAAE;IAAS;;IAE7D;IACA,IAAIb,KAAK,CAACY,MAAM,CAACF,QAAQ,CAAC,GAAG,CAAC,EAAE;MAAE;IAAS;;IAE3C;IACA,IAAII,SAAS,GAAG,KAAK;IACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGb,eAAe,CAACc,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;MACtD,IAAIZ,eAAe,CAACY,CAAC,CAAC,CAACf,KAAK,EAAEU,QAAQ,EAAER,OAAO,EAAE,IAAI,CAAC,EAAE;QACtDY,SAAS,GAAG,IAAI;QAChB;MACF;IACF;IACA,IAAIA,SAAS,EAAE;MAAE;IAAM;EACzB;EAEA,MAAMI,OAAO,GAAGlB,KAAK,CAACmB,QAAQ,CAAClB,SAAS,EAAES,QAAQ,EAAEV,KAAK,CAACa,SAAS,EAAE,KAAK,CAAC,CAACO,IAAI,CAAC,CAAC;EAElFpB,KAAK,CAACqB,IAAI,GAAGX,QAAQ;EAErB,MAAMY,OAAO,GAAMtB,KAAK,CAACuB,IAAI,CAAC,gBAAgB,EAAE,GAAG,EAAE,CAAC,CAAC;EACvDD,OAAO,CAACE,GAAG,GAAQ,CAACvB,SAAS,EAAED,KAAK,CAACqB,IAAI,CAAC;EAE1C,MAAMI,OAAO,GAAMzB,KAAK,CAACuB,IAAI,CAAC,QAAQ,EAAE,EAAE,EAAE,CAAC,CAAC;EAC9CE,OAAO,CAACP,OAAO,GAAIA,OAAO;EAC1BO,OAAO,CAACD,GAAG,GAAQ,CAACvB,SAAS,EAAED,KAAK,CAACqB,IAAI,CAAC;EAC1CI,OAAO,CAACC,QAAQ,GAAG,EAAE;EAErB1B,KAAK,CAACuB,IAAI,CAAC,iBAAiB,EAAE,GAAG,EAAE,CAAC,CAAC,CAAC;EAEtCvB,KAAK,CAACS,UAAU,GAAGD,aAAa;EAEhC,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}