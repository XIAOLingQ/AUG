{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Inline parser state\n\nimport Token from '../token.mjs';\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs';\nfunction StateInline(src, md, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.md = md;\n  this.tokens = outTokens;\n  this.tokens_meta = Array(outTokens.length);\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {};\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = [];\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = [];\n\n  // backtick length => last seen position\n  this.backticks = {};\n  this.backticksScanned = false;\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0;\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0);\n  token.content = this.pending;\n  token.level = this.pendingLevel;\n  this.tokens.push(token);\n  this.pending = '';\n  return token;\n};\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending();\n  }\n  const token = new Token(type, tag, nesting);\n  let token_meta = null;\n  if (nesting < 0) {\n    // closing tag\n    this.level--;\n    this.delimiters = this._prev_delimiters.pop();\n  }\n  token.level = this.level;\n  if (nesting > 0) {\n    // opening tag\n    this.level++;\n    this._prev_delimiters.push(this.delimiters);\n    this.delimiters = [];\n    token_meta = {\n      delimiters: this.delimiters\n    };\n  }\n  this.pendingLevel = this.level;\n  this.tokens.push(token);\n  this.tokens_meta.push(token_meta);\n  return token;\n};\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  const max = this.posMax;\n  const marker = this.src.charCodeAt(start);\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20;\n  let pos = start;\n  while (pos < max && this.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n  const count = pos - start;\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20;\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n  const isLastWhiteSpace = isWhiteSpace(lastChar);\n  const isNextWhiteSpace = isWhiteSpace(nextChar);\n  const left_flanking = !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar);\n  const right_flanking = !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar);\n  const can_open = left_flanking && (canSplitWord || !right_flanking || isLastPunctChar);\n  const can_close = right_flanking && (canSplitWord || !left_flanking || isNextPunctChar);\n  return {\n    can_open,\n    can_close,\n    length: count\n  };\n};\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token;\nexport default StateInline;","map":{"version":3,"names":["Token","isWhiteSpace","isPunctChar","isMdAsciiPunct","StateInline","src","md","env","outTokens","tokens","tokens_meta","Array","length","pos","posMax","level","pending","pendingLevel","cache","delimiters","_prev_delimiters","backticks","backticksScanned","linkLevel","prototype","pushPending","token","content","push","type","tag","nesting","token_meta","pop","scanDelims","start","canSplitWord","max","marker","charCodeAt","lastChar","count","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","left_flanking","right_flanking","can_open","can_close"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_inline/state_inline.mjs"],"sourcesContent":["// Inline parser state\n\nimport Token from '../token.mjs'\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nfunction StateInline (src, md, env, outTokens) {\n  this.src = src\n  this.env = env\n  this.md = md\n  this.tokens = outTokens\n  this.tokens_meta = Array(outTokens.length)\n\n  this.pos = 0\n  this.posMax = this.src.length\n  this.level = 0\n  this.pending = ''\n  this.pendingLevel = 0\n\n  // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  this.cache = {}\n\n  // List of emphasis-like delimiters for current tag\n  this.delimiters = []\n\n  // Stack of delimiter lists for upper level tags\n  this._prev_delimiters = []\n\n  // backtick length => last seen position\n  this.backticks = {}\n  this.backticksScanned = false\n\n  // Counter used to disable inline linkify-it execution\n  // inside <a> and markdown links\n  this.linkLevel = 0\n}\n\n// Flush pending text\n//\nStateInline.prototype.pushPending = function () {\n  const token = new Token('text', '', 0)\n  token.content = this.pending\n  token.level = this.pendingLevel\n  this.tokens.push(token)\n  this.pending = ''\n  return token\n}\n\n// Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\nStateInline.prototype.push = function (type, tag, nesting) {\n  if (this.pending) {\n    this.pushPending()\n  }\n\n  const token = new Token(type, tag, nesting)\n  let token_meta = null\n\n  if (nesting < 0) {\n    // closing tag\n    this.level--\n    this.delimiters = this._prev_delimiters.pop()\n  }\n\n  token.level = this.level\n\n  if (nesting > 0) {\n    // opening tag\n    this.level++\n    this._prev_delimiters.push(this.delimiters)\n    this.delimiters = []\n    token_meta = { delimiters: this.delimiters }\n  }\n\n  this.pendingLevel = this.level\n  this.tokens.push(token)\n  this.tokens_meta.push(token_meta)\n  return token\n}\n\n// Scan a sequence of emphasis-like markers, and determine whether\n// it can start an emphasis sequence or end an emphasis sequence.\n//\n//  - start - position to scan from (it should point at a valid marker);\n//  - canSplitWord - determine if these markers can be found inside a word\n//\nStateInline.prototype.scanDelims = function (start, canSplitWord) {\n  const max = this.posMax\n  const marker = this.src.charCodeAt(start)\n\n  // treat beginning of the line as a whitespace\n  const lastChar = start > 0 ? this.src.charCodeAt(start - 1) : 0x20\n\n  let pos = start\n  while (pos < max && this.src.charCodeAt(pos) === marker) { pos++ }\n\n  const count = pos - start\n\n  // treat end of the line as a whitespace\n  const nextChar = pos < max ? this.src.charCodeAt(pos) : 0x20\n\n  const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n  const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n  const isLastWhiteSpace = isWhiteSpace(lastChar)\n  const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n  const left_flanking =\n    !isNextWhiteSpace && (!isNextPunctChar || isLastWhiteSpace || isLastPunctChar)\n  const right_flanking =\n    !isLastWhiteSpace && (!isLastPunctChar || isNextWhiteSpace || isNextPunctChar)\n\n  const can_open  = left_flanking  && (canSplitWord || !right_flanking || isLastPunctChar)\n  const can_close = right_flanking && (canSplitWord || !left_flanking  || isNextPunctChar)\n\n  return { can_open, can_close, length: count }\n}\n\n// re-export Token class to use in block rules\nStateInline.prototype.Token = Token\n\nexport default StateInline\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}