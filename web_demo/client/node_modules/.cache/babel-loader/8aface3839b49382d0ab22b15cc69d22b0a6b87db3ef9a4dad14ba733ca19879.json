{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Horizontal rule\n\nimport { isSpace } from '../common/utils.mjs';\nexport default function hr(state, startLine, endLine, silent) {\n  const max = state.eMarks[startLine];\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  const marker = state.src.charCodeAt(pos++);\n\n  // Check hr marker\n  if (marker !== 0x2A /* * */ && marker !== 0x2D /* - */ && marker !== 0x5F /* _ */) {\n    return false;\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  let cnt = 1;\n  while (pos < max) {\n    const ch = state.src.charCodeAt(pos++);\n    if (ch !== marker && !isSpace(ch)) {\n      return false;\n    }\n    if (ch === marker) {\n      cnt++;\n    }\n  }\n  if (cnt < 3) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  state.line = startLine + 1;\n  const token = state.push('hr', 'hr', 0);\n  token.map = [startLine, state.line];\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker));\n  return true;\n}","map":{"version":3,"names":["isSpace","hr","state","startLine","endLine","silent","max","eMarks","sCount","blkIndent","pos","bMarks","tShift","marker","src","charCodeAt","cnt","ch","line","token","push","map","markup","Array","join","String","fromCharCode"],"sources":["E:/GLM-UML/web_demo/client/node_modules/markdown-it/lib/rules_block/hr.mjs"],"sourcesContent":["// Horizontal rule\n\nimport { isSpace } from '../common/utils.mjs'\n\nexport default function hr (state, startLine, endLine, silent) {\n  const max = state.eMarks[startLine]\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  const marker = state.src.charCodeAt(pos++)\n\n  // Check hr marker\n  if (marker !== 0x2A/* * */ &&\n      marker !== 0x2D/* - */ &&\n      marker !== 0x5F/* _ */) {\n    return false\n  }\n\n  // markers can be mixed with spaces, but there should be at least 3 of them\n\n  let cnt = 1\n  while (pos < max) {\n    const ch = state.src.charCodeAt(pos++)\n    if (ch !== marker && !isSpace(ch)) { return false }\n    if (ch === marker) { cnt++ }\n  }\n\n  if (cnt < 3) { return false }\n\n  if (silent) { return true }\n\n  state.line = startLine + 1\n\n  const token  = state.push('hr', 'hr', 0)\n  token.map    = [startLine, state.line]\n  token.markup = Array(cnt + 1).join(String.fromCharCode(marker))\n\n  return true\n}\n"],"mappings":";AAAA;;AAEA,SAASA,OAAO,QAAQ,qBAAqB;AAE7C,eAAe,SAASC,EAAEA,CAAEC,KAAK,EAAEC,SAAS,EAAEC,OAAO,EAAEC,MAAM,EAAE;EAC7D,MAAMC,GAAG,GAAGJ,KAAK,CAACK,MAAM,CAACJ,SAAS,CAAC;EACnC;EACA,IAAID,KAAK,CAACM,MAAM,CAACL,SAAS,CAAC,GAAGD,KAAK,CAACO,SAAS,IAAI,CAAC,EAAE;IAAE,OAAO,KAAK;EAAC;EAEnE,IAAIC,GAAG,GAAGR,KAAK,CAACS,MAAM,CAACR,SAAS,CAAC,GAAGD,KAAK,CAACU,MAAM,CAACT,SAAS,CAAC;EAC3D,MAAMU,MAAM,GAAGX,KAAK,CAACY,GAAG,CAACC,UAAU,CAACL,GAAG,EAAE,CAAC;;EAE1C;EACA,IAAIG,MAAM,KAAK,IAAI,YACfA,MAAM,KAAK,IAAI,YACfA,MAAM,KAAK,IAAI,UAAS;IAC1B,OAAO,KAAK;EACd;;EAEA;;EAEA,IAAIG,GAAG,GAAG,CAAC;EACX,OAAON,GAAG,GAAGJ,GAAG,EAAE;IAChB,MAAMW,EAAE,GAAGf,KAAK,CAACY,GAAG,CAACC,UAAU,CAACL,GAAG,EAAE,CAAC;IACtC,IAAIO,EAAE,KAAKJ,MAAM,IAAI,CAACb,OAAO,CAACiB,EAAE,CAAC,EAAE;MAAE,OAAO,KAAK;IAAC;IAClD,IAAIA,EAAE,KAAKJ,MAAM,EAAE;MAAEG,GAAG,EAAE;IAAC;EAC7B;EAEA,IAAIA,GAAG,GAAG,CAAC,EAAE;IAAE,OAAO,KAAK;EAAC;EAE5B,IAAIX,MAAM,EAAE;IAAE,OAAO,IAAI;EAAC;EAE1BH,KAAK,CAACgB,IAAI,GAAGf,SAAS,GAAG,CAAC;EAE1B,MAAMgB,KAAK,GAAIjB,KAAK,CAACkB,IAAI,CAAC,IAAI,EAAE,IAAI,EAAE,CAAC,CAAC;EACxCD,KAAK,CAACE,GAAG,GAAM,CAAClB,SAAS,EAAED,KAAK,CAACgB,IAAI,CAAC;EACtCC,KAAK,CAACG,MAAM,GAAGC,KAAK,CAACP,GAAG,GAAG,CAAC,CAAC,CAACQ,IAAI,CAACC,MAAM,CAACC,YAAY,CAACb,MAAM,CAAC,CAAC;EAE/D,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}