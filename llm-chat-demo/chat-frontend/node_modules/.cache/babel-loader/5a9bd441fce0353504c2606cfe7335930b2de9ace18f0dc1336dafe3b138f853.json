{"ast":null,"code":"// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A /* \\n */:\n    case 0x21 /* ! */:\n    case 0x23 /* # */:\n    case 0x24 /* $ */:\n    case 0x25 /* % */:\n    case 0x26 /* & */:\n    case 0x2A /* * */:\n    case 0x2B /* + */:\n    case 0x2D /* - */:\n    case 0x3A /* : */:\n    case 0x3C /* < */:\n    case 0x3D /* = */:\n    case 0x3E /* > */:\n    case 0x40 /* @ */:\n    case 0x5B /* [ */:\n    case 0x5C /* \\ */:\n    case 0x5D /* ] */:\n    case 0x5E /* ^ */:\n    case 0x5F /* _ */:\n    case 0x60 /* ` */:\n    case 0x7B /* { */:\n    case 0x7D /* } */:\n    case 0x7E /* ~ */:\n      return true;\n    default:\n      return false;\n  }\n}\nexport default function text(state, silent) {\n  let pos = state.pos;\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n  if (pos === state.pos) {\n    return false;\n  }\n  if (!silent) {\n    state.pending += state.src.slice(state.pos, pos);\n  }\n  state.pos = pos;\n  return true;\n}\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParserInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n}; */","map":{"version":3,"names":["isTerminatorChar","ch","text","state","silent","pos","posMax","src","charCodeAt","pending","slice"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_inline/text.mjs"],"sourcesContent":["// Skip text characters for text token, place those to pending buffer\n// and increment current pos\n\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n// !, \", #, $, %, &, ', (, ), *, +, ,, -, ., /, :, ;, <, =, >, ?, @, [, \\, ], ^, _, `, {, |, }, or ~\n\n// !!!! Don't confuse with \"Markdown ASCII Punctuation\" chars\n// http://spec.commonmark.org/0.15/#ascii-punctuation-character\nfunction isTerminatorChar (ch) {\n  switch (ch) {\n    case 0x0A/* \\n */:\n    case 0x21/* ! */:\n    case 0x23/* # */:\n    case 0x24/* $ */:\n    case 0x25/* % */:\n    case 0x26/* & */:\n    case 0x2A/* * */:\n    case 0x2B/* + */:\n    case 0x2D/* - */:\n    case 0x3A/* : */:\n    case 0x3C/* < */:\n    case 0x3D/* = */:\n    case 0x3E/* > */:\n    case 0x40/* @ */:\n    case 0x5B/* [ */:\n    case 0x5C/* \\ */:\n    case 0x5D/* ] */:\n    case 0x5E/* ^ */:\n    case 0x5F/* _ */:\n    case 0x60/* ` */:\n    case 0x7B/* { */:\n    case 0x7D/* } */:\n    case 0x7E/* ~ */:\n      return true\n    default:\n      return false\n  }\n}\n\nexport default function text (state, silent) {\n  let pos = state.pos\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++\n  }\n\n  if (pos === state.pos) { return false }\n\n  if (!silent) { state.pending += state.src.slice(state.pos, pos) }\n\n  state.pos = pos\n\n  return true\n}\n\n// Alternative implementation, for memory.\n//\n// It costs 10% of performance, but allows extend terminators list, if place it\n// to `ParserInline` property. Probably, will switch to it sometime, such\n// flexibility required.\n\n/*\nvar TERMINATOR_RE = /[\\n!#$%&*+\\-:<=>@[\\\\\\]^_`{}~]/;\n\nmodule.exports = function text(state, silent) {\n  var pos = state.pos,\n      idx = state.src.slice(pos).search(TERMINATOR_RE);\n\n  // first char is terminator -> empty text\n  if (idx === 0) { return false; }\n\n  // no terminator -> text till end of string\n  if (idx < 0) {\n    if (!silent) { state.pending += state.src.slice(pos); }\n    state.pos = state.src.length;\n    return true;\n  }\n\n  if (!silent) { state.pending += state.src.slice(pos, pos + idx); }\n\n  state.pos += idx;\n\n  return true;\n}; */\n"],"mappings":"AAAA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,SAASA,gBAAgBA,CAAEC,EAAE,EAAE;EAC7B,QAAQA,EAAE;IACR,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;IACT,KAAK,IAAI;MACP,OAAO,IAAI;IACb;MACE,OAAO,KAAK;EAChB;AACF;AAEA,eAAe,SAASC,IAAIA,CAAEC,KAAK,EAAEC,MAAM,EAAE;EAC3C,IAAIC,GAAG,GAAGF,KAAK,CAACE,GAAG;EAEnB,OAAOA,GAAG,GAAGF,KAAK,CAACG,MAAM,IAAI,CAACN,gBAAgB,CAACG,KAAK,CAACI,GAAG,CAACC,UAAU,CAACH,GAAG,CAAC,CAAC,EAAE;IACzEA,GAAG,EAAE;EACP;EAEA,IAAIA,GAAG,KAAKF,KAAK,CAACE,GAAG,EAAE;IAAE,OAAO,KAAK;EAAC;EAEtC,IAAI,CAACD,MAAM,EAAE;IAAED,KAAK,CAACM,OAAO,IAAIN,KAAK,CAACI,GAAG,CAACG,KAAK,CAACP,KAAK,CAACE,GAAG,EAAEA,GAAG,CAAC;EAAC;EAEhEF,KAAK,CAACE,GAAG,GAAGA,GAAG;EAEf,OAAO,IAAI;AACb;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}