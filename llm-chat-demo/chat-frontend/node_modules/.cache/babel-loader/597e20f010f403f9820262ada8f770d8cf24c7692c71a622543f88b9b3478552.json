{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Process block-level custom containers\n//\nexport default function container_plugin(md, name, options) {\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault(params /*, markup */) {\n    return params.trim().split(' ', 2)[0] === name;\n  }\n  function renderDefault(tokens, idx, _options, env, slf) {\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name);\n    }\n    return slf.renderToken(tokens, idx, _options, env, slf);\n  }\n  options = options || {};\n  const min_markers = 3;\n  const marker_str = options.marker || ':';\n  const marker_char = marker_str.charCodeAt(0);\n  const marker_len = marker_str.length;\n  const validate = options.validate || validateDefault;\n  const render = options.render || renderDefault;\n  function container(state, startLine, endLine, silent) {\n    let pos;\n    let auto_closed = false;\n    let start = state.bMarks[startLine] + state.tShift[startLine];\n    let max = state.eMarks[startLine];\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) {\n      return false;\n    }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break;\n      }\n    }\n    const marker_count = Math.floor((pos - start) / marker_len);\n    if (marker_count < min_markers) {\n      return false;\n    }\n    pos -= (pos - start) % marker_len;\n    const markup = state.src.slice(start, pos);\n    const params = state.src.slice(pos, max);\n    if (!validate(params, markup)) {\n      return false;\n    }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) {\n      return true;\n    }\n\n    // Search for the end of the block\n    //\n    let nextLine = startLine;\n    for (;;) {\n      nextLine++;\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break;\n      }\n      start = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break;\n      }\n      if (marker_char !== state.src.charCodeAt(start)) {\n        continue;\n      }\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue;\n      }\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break;\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) {\n        continue;\n      }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len;\n      pos = state.skipSpaces(pos);\n      if (pos < max) {\n        continue;\n      }\n\n      // found!\n      auto_closed = true;\n      break;\n    }\n    const old_parent = state.parentType;\n    const old_line_max = state.lineMax;\n    state.parentType = 'container';\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine;\n    const token_o = state.push('container_' + name + '_open', 'div', 1);\n    token_o.markup = markup;\n    token_o.block = true;\n    token_o.info = params;\n    token_o.map = [startLine, nextLine];\n    state.md.block.tokenize(state, startLine + 1, nextLine);\n    const token_c = state.push('container_' + name + '_close', 'div', -1);\n    token_c.markup = state.src.slice(start, pos);\n    token_c.block = true;\n    state.parentType = old_parent;\n    state.lineMax = old_line_max;\n    state.line = nextLine + (auto_closed ? 1 : 0);\n    return true;\n  }\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  });\n  md.renderer.rules['container_' + name + '_open'] = render;\n  md.renderer.rules['container_' + name + '_close'] = render;\n}\n;","map":{"version":3,"names":["container_plugin","md","name","options","validateDefault","params","trim","split","renderDefault","tokens","idx","_options","env","slf","nesting","attrJoin","renderToken","min_markers","marker_str","marker","marker_char","charCodeAt","marker_len","length","validate","render","container","state","startLine","endLine","silent","pos","auto_closed","start","bMarks","tShift","max","eMarks","src","marker_count","Math","floor","markup","slice","nextLine","sCount","blkIndent","skipSpaces","old_parent","parentType","old_line_max","lineMax","token_o","push","block","info","map","tokenize","token_c","line","ruler","before","alt","renderer","rules"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it-container/index.mjs"],"sourcesContent":["// Process block-level custom containers\n//\nexport default function container_plugin (md, name, options) {\n  // Second param may be useful if you decide\n  // to increase minimal allowed marker length\n  function validateDefault (params/*, markup */) {\n    return params.trim().split(' ', 2)[0] === name\n  }\n\n  function renderDefault (tokens, idx, _options, env, slf) {\n    // add a class to the opening tag\n    if (tokens[idx].nesting === 1) {\n      tokens[idx].attrJoin('class', name)\n    }\n\n    return slf.renderToken(tokens, idx, _options, env, slf)\n  }\n\n  options = options || {}\n\n  const min_markers = 3\n  const marker_str  = options.marker || ':'\n  const marker_char = marker_str.charCodeAt(0)\n  const marker_len  = marker_str.length\n  const validate    = options.validate || validateDefault\n  const render      = options.render || renderDefault\n\n  function container (state, startLine, endLine, silent) {\n    let pos\n    let auto_closed = false\n    let start = state.bMarks[startLine] + state.tShift[startLine]\n    let max = state.eMarks[startLine]\n\n    // Check out the first character quickly,\n    // this should filter out most of non-containers\n    //\n    if (marker_char !== state.src.charCodeAt(start)) { return false }\n\n    // Check out the rest of the marker string\n    //\n    for (pos = start + 1; pos <= max; pos++) {\n      if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n        break\n      }\n    }\n\n    const marker_count = Math.floor((pos - start) / marker_len)\n    if (marker_count < min_markers) { return false }\n    pos -= (pos - start) % marker_len\n\n    const markup = state.src.slice(start, pos)\n    const params = state.src.slice(pos, max)\n    if (!validate(params, markup)) { return false }\n\n    // Since start is found, we can report success here in validation mode\n    //\n    if (silent) { return true }\n\n    // Search for the end of the block\n    //\n    let nextLine = startLine\n\n    for (;;) {\n      nextLine++\n      if (nextLine >= endLine) {\n        // unclosed block should be autoclosed by end of document.\n        // also block seems to be autoclosed by end of parent\n        break\n      }\n\n      start = state.bMarks[nextLine] + state.tShift[nextLine]\n      max = state.eMarks[nextLine]\n\n      if (start < max && state.sCount[nextLine] < state.blkIndent) {\n        // non-empty line with negative indent should stop the list:\n        // - ```\n        //  test\n        break\n      }\n\n      if (marker_char !== state.src.charCodeAt(start)) { continue }\n\n      if (state.sCount[nextLine] - state.blkIndent >= 4) {\n        // closing fence should be indented less than 4 spaces\n        continue\n      }\n\n      for (pos = start + 1; pos <= max; pos++) {\n        if (marker_str[(pos - start) % marker_len] !== state.src[pos]) {\n          break\n        }\n      }\n\n      // closing code fence must be at least as long as the opening one\n      if (Math.floor((pos - start) / marker_len) < marker_count) { continue }\n\n      // make sure tail has spaces only\n      pos -= (pos - start) % marker_len\n      pos = state.skipSpaces(pos)\n\n      if (pos < max) { continue }\n\n      // found!\n      auto_closed = true\n      break\n    }\n\n    const old_parent = state.parentType\n    const old_line_max = state.lineMax\n    state.parentType = 'container'\n\n    // this will prevent lazy continuations from ever going past our end marker\n    state.lineMax = nextLine\n\n    const token_o  = state.push('container_' + name + '_open', 'div', 1)\n    token_o.markup = markup\n    token_o.block  = true\n    token_o.info   = params\n    token_o.map    = [startLine, nextLine]\n\n    state.md.block.tokenize(state, startLine + 1, nextLine)\n\n    const token_c  = state.push('container_' + name + '_close', 'div', -1)\n    token_c.markup = state.src.slice(start, pos)\n    token_c.block  = true\n\n    state.parentType = old_parent\n    state.lineMax = old_line_max\n    state.line = nextLine + (auto_closed ? 1 : 0)\n\n    return true\n  }\n\n  md.block.ruler.before('fence', 'container_' + name, container, {\n    alt: ['paragraph', 'reference', 'blockquote', 'list']\n  })\n  md.renderer.rules['container_' + name + '_open'] = render\n  md.renderer.rules['container_' + name + '_close'] = render\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}