{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// Convert straight quotation marks to typographic ones\n//\n\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs';\nconst QUOTE_TEST_RE = /['\"]/;\nconst QUOTE_RE = /['\"]/g;\nconst APOSTROPHE = '\\u2019'; /* ’ */\n\nfunction replaceAt(str, index, ch) {\n  return str.slice(0, index) + ch + str.slice(index + 1);\n}\nfunction process_inlines(tokens, state) {\n  let j;\n  const stack = [];\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const thisLevel = tokens[i].level;\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) {\n        break;\n      }\n    }\n    stack.length = j + 1;\n    if (token.type !== 'text') {\n      continue;\n    }\n    let text = token.content;\n    let pos = 0;\n    let max = text.length;\n\n    /* eslint no-labels:0,block-scoped-var:0 */\n    OUTER: while (pos < max) {\n      QUOTE_RE.lastIndex = pos;\n      const t = QUOTE_RE.exec(text);\n      if (!t) {\n        break;\n      }\n      let canOpen = true;\n      let canClose = true;\n      pos = t.index + 1;\n      const isSingle = t[0] === \"'\";\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      let lastChar = 0x20;\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1);\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // lastChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1);\n          break;\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      let nextChar = 0x20;\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos);\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break; // nextChar defaults to 0x20\n          if (!tokens[j].content) continue; // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0);\n          break;\n        }\n      }\n      const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar));\n      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar));\n      const isLastWhiteSpace = isWhiteSpace(lastChar);\n      const isNextWhiteSpace = isWhiteSpace(nextChar);\n      if (isNextWhiteSpace) {\n        canOpen = false;\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false;\n        }\n      }\n      if (isLastWhiteSpace) {\n        canClose = false;\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false;\n        }\n      }\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false;\n        }\n      }\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar;\n        canClose = isNextPunctChar;\n      }\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n        continue;\n      }\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          let item = stack[j];\n          if (stack[j].level < thisLevel) {\n            break;\n          }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j];\n            let openQuote;\n            let closeQuote;\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2];\n              closeQuote = state.md.options.quotes[3];\n            } else {\n              openQuote = state.md.options.quotes[0];\n              closeQuote = state.md.options.quotes[1];\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote);\n            tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, openQuote);\n            pos += closeQuote.length - 1;\n            if (item.token === i) {\n              pos += openQuote.length - 1;\n            }\n            text = token.content;\n            max = text.length;\n            stack.length = j;\n            continue OUTER;\n          }\n        }\n      }\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        });\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE);\n      }\n    }\n  }\n}\nexport default function smartquotes(state) {\n  /* eslint max-depth:0 */\n  if (!state.md.options.typographer) {\n    return;\n  }\n  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline' || !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue;\n    }\n    process_inlines(state.tokens[blkIdx].children, state);\n  }\n}","map":{"version":3,"names":["isWhiteSpace","isPunctChar","isMdAsciiPunct","QUOTE_TEST_RE","QUOTE_RE","APOSTROPHE","replaceAt","str","index","ch","slice","process_inlines","tokens","state","j","stack","i","length","token","thisLevel","level","type","text","content","pos","max","OUTER","lastIndex","t","exec","canOpen","canClose","isSingle","lastChar","charCodeAt","nextChar","isLastPunctChar","String","fromCharCode","isNextPunctChar","isLastWhiteSpace","isNextWhiteSpace","item","single","openQuote","closeQuote","md","options","quotes","push","smartquotes","typographer","blkIdx","test","children"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_core/smartquotes.mjs"],"sourcesContent":["// Convert straight quotation marks to typographic ones\n//\n\nimport { isWhiteSpace, isPunctChar, isMdAsciiPunct } from '../common/utils.mjs'\n\nconst QUOTE_TEST_RE = /['\"]/\nconst QUOTE_RE = /['\"]/g\nconst APOSTROPHE = '\\u2019' /* ’ */\n\nfunction replaceAt (str, index, ch) {\n  return str.slice(0, index) + ch + str.slice(index + 1)\n}\n\nfunction process_inlines (tokens, state) {\n  let j\n\n  const stack = []\n\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n\n    const thisLevel = tokens[i].level\n\n    for (j = stack.length - 1; j >= 0; j--) {\n      if (stack[j].level <= thisLevel) { break }\n    }\n    stack.length = j + 1\n\n    if (token.type !== 'text') { continue }\n\n    let text = token.content\n    let pos = 0\n    let max = text.length\n\n    /* eslint no-labels:0,block-scoped-var:0 */\n    OUTER:\n    while (pos < max) {\n      QUOTE_RE.lastIndex = pos\n      const t = QUOTE_RE.exec(text)\n      if (!t) { break }\n\n      let canOpen = true\n      let canClose = true\n      pos = t.index + 1\n      const isSingle = (t[0] === \"'\")\n\n      // Find previous character,\n      // default to space if it's the beginning of the line\n      //\n      let lastChar = 0x20\n\n      if (t.index - 1 >= 0) {\n        lastChar = text.charCodeAt(t.index - 1)\n      } else {\n        for (j = i - 1; j >= 0; j--) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // lastChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          lastChar = tokens[j].content.charCodeAt(tokens[j].content.length - 1)\n          break\n        }\n      }\n\n      // Find next character,\n      // default to space if it's the end of the line\n      //\n      let nextChar = 0x20\n\n      if (pos < max) {\n        nextChar = text.charCodeAt(pos)\n      } else {\n        for (j = i + 1; j < tokens.length; j++) {\n          if (tokens[j].type === 'softbreak' || tokens[j].type === 'hardbreak') break // nextChar defaults to 0x20\n          if (!tokens[j].content) continue // should skip all tokens except 'text', 'html_inline' or 'code_inline'\n\n          nextChar = tokens[j].content.charCodeAt(0)\n          break\n        }\n      }\n\n      const isLastPunctChar = isMdAsciiPunct(lastChar) || isPunctChar(String.fromCharCode(lastChar))\n      const isNextPunctChar = isMdAsciiPunct(nextChar) || isPunctChar(String.fromCharCode(nextChar))\n\n      const isLastWhiteSpace = isWhiteSpace(lastChar)\n      const isNextWhiteSpace = isWhiteSpace(nextChar)\n\n      if (isNextWhiteSpace) {\n        canOpen = false\n      } else if (isNextPunctChar) {\n        if (!(isLastWhiteSpace || isLastPunctChar)) {\n          canOpen = false\n        }\n      }\n\n      if (isLastWhiteSpace) {\n        canClose = false\n      } else if (isLastPunctChar) {\n        if (!(isNextWhiteSpace || isNextPunctChar)) {\n          canClose = false\n        }\n      }\n\n      if (nextChar === 0x22 /* \" */ && t[0] === '\"') {\n        if (lastChar >= 0x30 /* 0 */ && lastChar <= 0x39 /* 9 */) {\n          // special case: 1\"\" - count first quote as an inch\n          canClose = canOpen = false\n        }\n      }\n\n      if (canOpen && canClose) {\n        // Replace quotes in the middle of punctuation sequence, but not\n        // in the middle of the words, i.e.:\n        //\n        // 1. foo \" bar \" baz - not replaced\n        // 2. foo-\"-bar-\"-baz - replaced\n        // 3. foo\"bar\"baz     - not replaced\n        //\n        canOpen = isLastPunctChar\n        canClose = isNextPunctChar\n      }\n\n      if (!canOpen && !canClose) {\n        // middle of word\n        if (isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE)\n        }\n        continue\n      }\n\n      if (canClose) {\n        // this could be a closing quote, rewind the stack to get a match\n        for (j = stack.length - 1; j >= 0; j--) {\n          let item = stack[j]\n          if (stack[j].level < thisLevel) { break }\n          if (item.single === isSingle && stack[j].level === thisLevel) {\n            item = stack[j]\n\n            let openQuote\n            let closeQuote\n            if (isSingle) {\n              openQuote = state.md.options.quotes[2]\n              closeQuote = state.md.options.quotes[3]\n            } else {\n              openQuote = state.md.options.quotes[0]\n              closeQuote = state.md.options.quotes[1]\n            }\n\n            // replace token.content *before* tokens[item.token].content,\n            // because, if they are pointing at the same token, replaceAt\n            // could mess up indices when quote length != 1\n            token.content = replaceAt(token.content, t.index, closeQuote)\n            tokens[item.token].content = replaceAt(\n              tokens[item.token].content, item.pos, openQuote)\n\n            pos += closeQuote.length - 1\n            if (item.token === i) { pos += openQuote.length - 1 }\n\n            text = token.content\n            max = text.length\n\n            stack.length = j\n            continue OUTER\n          }\n        }\n      }\n\n      if (canOpen) {\n        stack.push({\n          token: i,\n          pos: t.index,\n          single: isSingle,\n          level: thisLevel\n        })\n      } else if (canClose && isSingle) {\n        token.content = replaceAt(token.content, t.index, APOSTROPHE)\n      }\n    }\n  }\n}\n\nexport default function smartquotes (state) {\n  /* eslint max-depth:0 */\n  if (!state.md.options.typographer) { return }\n\n  for (let blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline' ||\n        !QUOTE_TEST_RE.test(state.tokens[blkIdx].content)) {\n      continue\n    }\n\n    process_inlines(state.tokens[blkIdx].children, state)\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}