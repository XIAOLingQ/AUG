{"ast":null,"code":"import { isSpace, normalizeReference } from '../common/utils.mjs';\nexport default function reference(state, startLine, _endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  let max = state.eMarks[startLine];\n  let nextLine = startLine + 1;\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (state.src.charCodeAt(pos) !== 0x5B /* [ */) {\n    return false;\n  }\n  function getNextLine(nextLine) {\n    const endLine = state.lineMax;\n    if (nextLine >= endLine || state.isEmpty(nextLine)) {\n      // empty line or end of input\n      return null;\n    }\n    let isContinuation = false;\n\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) {\n      isContinuation = true;\n    }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) {\n      isContinuation = true;\n    }\n    if (!isContinuation) {\n      const terminatorRules = state.md.block.ruler.getRules('reference');\n      const oldParentType = state.parentType;\n      state.parentType = 'reference';\n\n      // Some tags can terminate paragraph without empty line.\n      let terminate = false;\n      for (let i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n      state.parentType = oldParentType;\n      if (terminate) {\n        // terminated by another block\n        return null;\n      }\n    }\n    const pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    const max = state.eMarks[nextLine];\n\n    // max + 1 explicitly includes the newline\n    return state.src.slice(pos, max + 1);\n  }\n  let str = state.src.slice(pos, max + 1);\n  max = str.length;\n  let labelEnd = -1;\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n    if (ch === 0x5B /* [ */) {\n      return false;\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos;\n      break;\n    } else if (ch === 0x0A /* \\n */) {\n      const lineContent = getNextLine(nextLine);\n      if (lineContent !== null) {\n        str += lineContent;\n        max = str.length;\n        nextLine++;\n      }\n    } else if (ch === 0x5C /* \\ */) {\n      pos++;\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        const lineContent = getNextLine(nextLine);\n        if (lineContent !== null) {\n          str += lineContent;\n          max = str.length;\n          nextLine++;\n        }\n      }\n    }\n  }\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A /* : */) {\n    return false;\n  }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine);\n      if (lineContent !== null) {\n        str += lineContent;\n        max = str.length;\n        nextLine++;\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max);\n  if (!destRes.ok) {\n    return false;\n  }\n  const href = state.md.normalizeLink(destRes.str);\n  if (!state.md.validateLink(href)) {\n    return false;\n  }\n  pos = destRes.pos;\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos;\n  const destEndLineNo = nextLine;\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos;\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos);\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine);\n      if (lineContent !== null) {\n        str += lineContent;\n        max = str.length;\n        nextLine++;\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break;\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max);\n  while (titleRes.can_continue) {\n    const lineContent = getNextLine(nextLine);\n    if (lineContent === null) break;\n    str += lineContent;\n    pos = max;\n    max = str.length;\n    nextLine++;\n    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes);\n  }\n  let title;\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str;\n    pos = titleRes.pos;\n  } else {\n    title = '';\n    pos = destEndPos;\n    nextLine = destEndLineNo;\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos);\n    if (!isSpace(ch)) {\n      break;\n    }\n    pos++;\n  }\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = '';\n      pos = destEndPos;\n      nextLine = destEndLineNo;\n      while (pos < max) {\n        const ch = str.charCodeAt(pos);\n        if (!isSpace(ch)) {\n          break;\n        }\n        pos++;\n      }\n    }\n  }\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false;\n  }\n  const label = normalizeReference(str.slice(1, labelEnd));\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false;\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) {\n    return true;\n  }\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {};\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = {\n      title,\n      href\n    };\n  }\n  state.line = nextLine;\n  return true;\n}","map":{"version":3,"names":["isSpace","normalizeReference","reference","state","startLine","_endLine","silent","pos","bMarks","tShift","max","eMarks","nextLine","sCount","blkIndent","src","charCodeAt","getNextLine","endLine","lineMax","isEmpty","isContinuation","terminatorRules","md","block","ruler","getRules","oldParentType","parentType","terminate","i","l","length","slice","str","labelEnd","ch","lineContent","destRes","helpers","parseLinkDestination","ok","href","normalizeLink","validateLink","destEndPos","destEndLineNo","start","titleRes","parseLinkTitle","can_continue","title","label","env","references","line"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_block/reference.mjs"],"sourcesContent":["import { isSpace, normalizeReference } from '../common/utils.mjs'\n\nexport default function reference (state, startLine, _endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n  let nextLine = startLine + 1\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x5B/* [ */) { return false }\n\n  function getNextLine (nextLine) {\n    const endLine = state.lineMax\n\n    if (nextLine >= endLine || state.isEmpty(nextLine)) {\n      // empty line or end of input\n      return null\n    }\n\n    let isContinuation = false\n\n    // this would be a code block normally, but after paragraph\n    // it's considered a lazy continuation regardless of what's there\n    if (state.sCount[nextLine] - state.blkIndent > 3) { isContinuation = true }\n\n    // quirk for blockquotes, this line should already be checked by that rule\n    if (state.sCount[nextLine] < 0) { isContinuation = true }\n\n    if (!isContinuation) {\n      const terminatorRules = state.md.block.ruler.getRules('reference')\n      const oldParentType = state.parentType\n      state.parentType = 'reference'\n\n      // Some tags can terminate paragraph without empty line.\n      let terminate = false\n      for (let i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true\n          break\n        }\n      }\n\n      state.parentType = oldParentType\n      if (terminate) {\n        // terminated by another block\n        return null\n      }\n    }\n\n    const pos = state.bMarks[nextLine] + state.tShift[nextLine]\n    const max = state.eMarks[nextLine]\n\n    // max + 1 explicitly includes the newline\n    return state.src.slice(pos, max + 1)\n  }\n\n  let str = state.src.slice(pos, max + 1)\n\n  max = str.length\n  let labelEnd = -1\n\n  for (pos = 1; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x5B /* [ */) {\n      return false\n    } else if (ch === 0x5D /* ] */) {\n      labelEnd = pos\n      break\n    } else if (ch === 0x0A /* \\n */) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (ch === 0x5C /* \\ */) {\n      pos++\n      if (pos < max && str.charCodeAt(pos) === 0x0A) {\n        const lineContent = getNextLine(nextLine)\n        if (lineContent !== null) {\n          str += lineContent\n          max = str.length\n          nextLine++\n        }\n      }\n    }\n  }\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A/* : */) { return false }\n\n  // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n  const destRes = state.md.helpers.parseLinkDestination(str, pos, max)\n  if (!destRes.ok) { return false }\n\n  const href = state.md.normalizeLink(destRes.str)\n  if (!state.md.validateLink(href)) { return false }\n\n  pos = destRes.pos\n\n  // save cursor state, we could require to rollback later\n  const destEndPos = pos\n  const destEndLineNo = nextLine\n\n  // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n  const start = pos\n  for (; pos < max; pos++) {\n    const ch = str.charCodeAt(pos)\n    if (ch === 0x0A) {\n      const lineContent = getNextLine(nextLine)\n      if (lineContent !== null) {\n        str += lineContent\n        max = str.length\n        nextLine++\n      }\n    } else if (isSpace(ch)) {\n      /* eslint no-empty:0 */\n    } else {\n      break\n    }\n  }\n\n  // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n  let titleRes = state.md.helpers.parseLinkTitle(str, pos, max)\n  while (titleRes.can_continue) {\n    const lineContent = getNextLine(nextLine)\n    if (lineContent === null) break\n    str += lineContent\n    pos = max\n    max = str.length\n    nextLine++\n    titleRes = state.md.helpers.parseLinkTitle(str, pos, max, titleRes)\n  }\n  let title\n\n  if (pos < max && start !== pos && titleRes.ok) {\n    title = titleRes.str\n    pos = titleRes.pos\n  } else {\n    title = ''\n    pos = destEndPos\n    nextLine = destEndLineNo\n  }\n\n  // skip trailing spaces until the rest of the line\n  while (pos < max) {\n    const ch = str.charCodeAt(pos)\n    if (!isSpace(ch)) { break }\n    pos++\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    if (title) {\n      // garbage at the end of the line after title,\n      // but it could still be a valid reference if we roll back\n      title = ''\n      pos = destEndPos\n      nextLine = destEndLineNo\n      while (pos < max) {\n        const ch = str.charCodeAt(pos)\n        if (!isSpace(ch)) { break }\n        pos++\n      }\n    }\n  }\n\n  if (pos < max && str.charCodeAt(pos) !== 0x0A) {\n    // garbage at the end of the line\n    return false\n  }\n\n  const label = normalizeReference(str.slice(1, labelEnd))\n  if (!label) {\n    // CommonMark 0.20 disallows empty labels\n    return false\n  }\n\n  // Reference can not terminate anything. This check is for safety only.\n  /* istanbul ignore if */\n  if (silent) { return true }\n\n  if (typeof state.env.references === 'undefined') {\n    state.env.references = {}\n  }\n  if (typeof state.env.references[label] === 'undefined') {\n    state.env.references[label] = { title, href }\n  }\n\n  state.line = nextLine\n  return true\n}\n"],"mappings":"AAAA,SAASA,OAAO,EAAEC,kBAAkB,QAAQ,qBAAqB;AAEjE,eAAe,SAASC,SAASA,CAAEC,KAAK,EAAEC,SAAS,EAAEC,QAAQ,EAAEC,MAAM,EAAE;EACrE,IAAIC,GAAG,GAAGJ,KAAK,CAACK,MAAM,CAACJ,SAAS,CAAC,GAAGD,KAAK,CAACM,MAAM,CAACL,SAAS,CAAC;EAC3D,IAAIM,GAAG,GAAGP,KAAK,CAACQ,MAAM,CAACP,SAAS,CAAC;EACjC,IAAIQ,QAAQ,GAAGR,SAAS,GAAG,CAAC;;EAE5B;EACA,IAAID,KAAK,CAACU,MAAM,CAACT,SAAS,CAAC,GAAGD,KAAK,CAACW,SAAS,IAAI,CAAC,EAAE;IAAE,OAAO,KAAK;EAAC;EAEnE,IAAIX,KAAK,CAACY,GAAG,CAACC,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,UAAS;IAAE,OAAO,KAAK;EAAC;EAE9D,SAASU,WAAWA,CAAEL,QAAQ,EAAE;IAC9B,MAAMM,OAAO,GAAGf,KAAK,CAACgB,OAAO;IAE7B,IAAIP,QAAQ,IAAIM,OAAO,IAAIf,KAAK,CAACiB,OAAO,CAACR,QAAQ,CAAC,EAAE;MAClD;MACA,OAAO,IAAI;IACb;IAEA,IAAIS,cAAc,GAAG,KAAK;;IAE1B;IACA;IACA,IAAIlB,KAAK,CAACU,MAAM,CAACD,QAAQ,CAAC,GAAGT,KAAK,CAACW,SAAS,GAAG,CAAC,EAAE;MAAEO,cAAc,GAAG,IAAI;IAAC;;IAE1E;IACA,IAAIlB,KAAK,CAACU,MAAM,CAACD,QAAQ,CAAC,GAAG,CAAC,EAAE;MAAES,cAAc,GAAG,IAAI;IAAC;IAExD,IAAI,CAACA,cAAc,EAAE;MACnB,MAAMC,eAAe,GAAGnB,KAAK,CAACoB,EAAE,CAACC,KAAK,CAACC,KAAK,CAACC,QAAQ,CAAC,WAAW,CAAC;MAClE,MAAMC,aAAa,GAAGxB,KAAK,CAACyB,UAAU;MACtCzB,KAAK,CAACyB,UAAU,GAAG,WAAW;;MAE9B;MACA,IAAIC,SAAS,GAAG,KAAK;MACrB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEC,CAAC,GAAGT,eAAe,CAACU,MAAM,EAAEF,CAAC,GAAGC,CAAC,EAAED,CAAC,EAAE,EAAE;QACtD,IAAIR,eAAe,CAACQ,CAAC,CAAC,CAAC3B,KAAK,EAAES,QAAQ,EAAEM,OAAO,EAAE,IAAI,CAAC,EAAE;UACtDW,SAAS,GAAG,IAAI;UAChB;QACF;MACF;MAEA1B,KAAK,CAACyB,UAAU,GAAGD,aAAa;MAChC,IAAIE,SAAS,EAAE;QACb;QACA,OAAO,IAAI;MACb;IACF;IAEA,MAAMtB,GAAG,GAAGJ,KAAK,CAACK,MAAM,CAACI,QAAQ,CAAC,GAAGT,KAAK,CAACM,MAAM,CAACG,QAAQ,CAAC;IAC3D,MAAMF,GAAG,GAAGP,KAAK,CAACQ,MAAM,CAACC,QAAQ,CAAC;;IAElC;IACA,OAAOT,KAAK,CAACY,GAAG,CAACkB,KAAK,CAAC1B,GAAG,EAAEG,GAAG,GAAG,CAAC,CAAC;EACtC;EAEA,IAAIwB,GAAG,GAAG/B,KAAK,CAACY,GAAG,CAACkB,KAAK,CAAC1B,GAAG,EAAEG,GAAG,GAAG,CAAC,CAAC;EAEvCA,GAAG,GAAGwB,GAAG,CAACF,MAAM;EAChB,IAAIG,QAAQ,GAAG,CAAC,CAAC;EAEjB,KAAK5B,GAAG,GAAG,CAAC,EAAEA,GAAG,GAAGG,GAAG,EAAEH,GAAG,EAAE,EAAE;IAC9B,MAAM6B,EAAE,GAAGF,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI6B,EAAE,KAAK,IAAI,CAAC,SAAS;MACvB,OAAO,KAAK;IACd,CAAC,MAAM,IAAIA,EAAE,KAAK,IAAI,CAAC,SAAS;MAC9BD,QAAQ,GAAG5B,GAAG;MACd;IACF,CAAC,MAAM,IAAI6B,EAAE,KAAK,IAAI,CAAC,UAAU;MAC/B,MAAMC,WAAW,GAAGpB,WAAW,CAACL,QAAQ,CAAC;MACzC,IAAIyB,WAAW,KAAK,IAAI,EAAE;QACxBH,GAAG,IAAIG,WAAW;QAClB3B,GAAG,GAAGwB,GAAG,CAACF,MAAM;QAChBpB,QAAQ,EAAE;MACZ;IACF,CAAC,MAAM,IAAIwB,EAAE,KAAK,IAAI,CAAC,SAAS;MAC9B7B,GAAG,EAAE;MACL,IAAIA,GAAG,GAAGG,GAAG,IAAIwB,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,EAAE;QAC7C,MAAM8B,WAAW,GAAGpB,WAAW,CAACL,QAAQ,CAAC;QACzC,IAAIyB,WAAW,KAAK,IAAI,EAAE;UACxBH,GAAG,IAAIG,WAAW;UAClB3B,GAAG,GAAGwB,GAAG,CAACF,MAAM;UAChBpB,QAAQ,EAAE;QACZ;MACF;IACF;EACF;EAEA,IAAIuB,QAAQ,GAAG,CAAC,IAAID,GAAG,CAAClB,UAAU,CAACmB,QAAQ,GAAG,CAAC,CAAC,KAAK,IAAI,UAAS;IAAE,OAAO,KAAK;EAAC;;EAEjF;EACA;EACA,KAAK5B,GAAG,GAAG4B,QAAQ,GAAG,CAAC,EAAE5B,GAAG,GAAGG,GAAG,EAAEH,GAAG,EAAE,EAAE;IACzC,MAAM6B,EAAE,GAAGF,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI6B,EAAE,KAAK,IAAI,EAAE;MACf,MAAMC,WAAW,GAAGpB,WAAW,CAACL,QAAQ,CAAC;MACzC,IAAIyB,WAAW,KAAK,IAAI,EAAE;QACxBH,GAAG,IAAIG,WAAW;QAClB3B,GAAG,GAAGwB,GAAG,CAACF,MAAM;QAChBpB,QAAQ,EAAE;MACZ;IACF,CAAC,MAAM,IAAIZ,OAAO,CAACoC,EAAE,CAAC,EAAE;MACtB;IAAA,CACD,MAAM;MACL;IACF;EACF;;EAEA;EACA;EACA,MAAME,OAAO,GAAGnC,KAAK,CAACoB,EAAE,CAACgB,OAAO,CAACC,oBAAoB,CAACN,GAAG,EAAE3B,GAAG,EAAEG,GAAG,CAAC;EACpE,IAAI,CAAC4B,OAAO,CAACG,EAAE,EAAE;IAAE,OAAO,KAAK;EAAC;EAEhC,MAAMC,IAAI,GAAGvC,KAAK,CAACoB,EAAE,CAACoB,aAAa,CAACL,OAAO,CAACJ,GAAG,CAAC;EAChD,IAAI,CAAC/B,KAAK,CAACoB,EAAE,CAACqB,YAAY,CAACF,IAAI,CAAC,EAAE;IAAE,OAAO,KAAK;EAAC;EAEjDnC,GAAG,GAAG+B,OAAO,CAAC/B,GAAG;;EAEjB;EACA,MAAMsC,UAAU,GAAGtC,GAAG;EACtB,MAAMuC,aAAa,GAAGlC,QAAQ;;EAE9B;EACA;EACA,MAAMmC,KAAK,GAAGxC,GAAG;EACjB,OAAOA,GAAG,GAAGG,GAAG,EAAEH,GAAG,EAAE,EAAE;IACvB,MAAM6B,EAAE,GAAGF,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI6B,EAAE,KAAK,IAAI,EAAE;MACf,MAAMC,WAAW,GAAGpB,WAAW,CAACL,QAAQ,CAAC;MACzC,IAAIyB,WAAW,KAAK,IAAI,EAAE;QACxBH,GAAG,IAAIG,WAAW;QAClB3B,GAAG,GAAGwB,GAAG,CAACF,MAAM;QAChBpB,QAAQ,EAAE;MACZ;IACF,CAAC,MAAM,IAAIZ,OAAO,CAACoC,EAAE,CAAC,EAAE;MACtB;IAAA,CACD,MAAM;MACL;IACF;EACF;;EAEA;EACA;EACA,IAAIY,QAAQ,GAAG7C,KAAK,CAACoB,EAAE,CAACgB,OAAO,CAACU,cAAc,CAACf,GAAG,EAAE3B,GAAG,EAAEG,GAAG,CAAC;EAC7D,OAAOsC,QAAQ,CAACE,YAAY,EAAE;IAC5B,MAAMb,WAAW,GAAGpB,WAAW,CAACL,QAAQ,CAAC;IACzC,IAAIyB,WAAW,KAAK,IAAI,EAAE;IAC1BH,GAAG,IAAIG,WAAW;IAClB9B,GAAG,GAAGG,GAAG;IACTA,GAAG,GAAGwB,GAAG,CAACF,MAAM;IAChBpB,QAAQ,EAAE;IACVoC,QAAQ,GAAG7C,KAAK,CAACoB,EAAE,CAACgB,OAAO,CAACU,cAAc,CAACf,GAAG,EAAE3B,GAAG,EAAEG,GAAG,EAAEsC,QAAQ,CAAC;EACrE;EACA,IAAIG,KAAK;EAET,IAAI5C,GAAG,GAAGG,GAAG,IAAIqC,KAAK,KAAKxC,GAAG,IAAIyC,QAAQ,CAACP,EAAE,EAAE;IAC7CU,KAAK,GAAGH,QAAQ,CAACd,GAAG;IACpB3B,GAAG,GAAGyC,QAAQ,CAACzC,GAAG;EACpB,CAAC,MAAM;IACL4C,KAAK,GAAG,EAAE;IACV5C,GAAG,GAAGsC,UAAU;IAChBjC,QAAQ,GAAGkC,aAAa;EAC1B;;EAEA;EACA,OAAOvC,GAAG,GAAGG,GAAG,EAAE;IAChB,MAAM0B,EAAE,GAAGF,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC;IAC9B,IAAI,CAACP,OAAO,CAACoC,EAAE,CAAC,EAAE;MAAE;IAAM;IAC1B7B,GAAG,EAAE;EACP;EAEA,IAAIA,GAAG,GAAGG,GAAG,IAAIwB,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,EAAE;IAC7C,IAAI4C,KAAK,EAAE;MACT;MACA;MACAA,KAAK,GAAG,EAAE;MACV5C,GAAG,GAAGsC,UAAU;MAChBjC,QAAQ,GAAGkC,aAAa;MACxB,OAAOvC,GAAG,GAAGG,GAAG,EAAE;QAChB,MAAM0B,EAAE,GAAGF,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC;QAC9B,IAAI,CAACP,OAAO,CAACoC,EAAE,CAAC,EAAE;UAAE;QAAM;QAC1B7B,GAAG,EAAE;MACP;IACF;EACF;EAEA,IAAIA,GAAG,GAAGG,GAAG,IAAIwB,GAAG,CAAClB,UAAU,CAACT,GAAG,CAAC,KAAK,IAAI,EAAE;IAC7C;IACA,OAAO,KAAK;EACd;EAEA,MAAM6C,KAAK,GAAGnD,kBAAkB,CAACiC,GAAG,CAACD,KAAK,CAAC,CAAC,EAAEE,QAAQ,CAAC,CAAC;EACxD,IAAI,CAACiB,KAAK,EAAE;IACV;IACA,OAAO,KAAK;EACd;;EAEA;EACA;EACA,IAAI9C,MAAM,EAAE;IAAE,OAAO,IAAI;EAAC;EAE1B,IAAI,OAAOH,KAAK,CAACkD,GAAG,CAACC,UAAU,KAAK,WAAW,EAAE;IAC/CnD,KAAK,CAACkD,GAAG,CAACC,UAAU,GAAG,CAAC,CAAC;EAC3B;EACA,IAAI,OAAOnD,KAAK,CAACkD,GAAG,CAACC,UAAU,CAACF,KAAK,CAAC,KAAK,WAAW,EAAE;IACtDjD,KAAK,CAACkD,GAAG,CAACC,UAAU,CAACF,KAAK,CAAC,GAAG;MAAED,KAAK;MAAET;IAAK,CAAC;EAC/C;EAEAvC,KAAK,CAACoD,IAAI,GAAG3C,QAAQ;EACrB,OAAO,IAAI;AACb","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}