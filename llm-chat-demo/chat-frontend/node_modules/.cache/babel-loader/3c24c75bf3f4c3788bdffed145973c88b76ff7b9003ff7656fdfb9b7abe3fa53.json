{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// For each opening emphasis-like marker find a matching closing one\n//\n\nfunction processDelimiters(delimiters) {\n  const openersBottom = {};\n  const max = delimiters.length;\n  if (!max) return;\n\n  // headerIdx is the first delimiter of the current (where closer is) delimiter run\n  let headerIdx = 0;\n  let lastTokenIdx = -2; // needs any value lower than -1\n  const jumps = [];\n  for (let closerIdx = 0; closerIdx < max; closerIdx++) {\n    const closer = delimiters[closerIdx];\n    jumps.push(0);\n\n    // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx;\n    }\n    lastTokenIdx = closer.token;\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0;\n    if (!closer.close) continue;\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    /* eslint-disable-next-line no-prototype-builtins */\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1];\n    }\n    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + closer.length % 3];\n    let openerIdx = headerIdx - jumps[headerIdx] - 1;\n    let newMinOpenerIdx = openerIdx;\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      const opener = delimiters[openerIdx];\n      if (opener.marker !== closer.marker) continue;\n      if (opener.open && opener.end < 0) {\n        let isOddMatch = false;\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true;\n            }\n          }\n        }\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open ? jumps[openerIdx - 1] + 1 : 0;\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump;\n          jumps[openerIdx] = lastJump;\n          closer.open = false;\n          opener.end = closerIdx;\n          opener.close = false;\n          newMinOpenerIdx = -1;\n          // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n          lastTokenIdx = -2;\n          break;\n        }\n      }\n    }\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length || 0) % 3] = newMinOpenerIdx;\n    }\n  }\n}\nexport default function link_pairs(state) {\n  const tokens_meta = state.tokens_meta;\n  const max = state.tokens_meta.length;\n  processDelimiters(state.delimiters);\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(tokens_meta[curr].delimiters);\n    }\n  }\n}","map":{"version":3,"names":["processDelimiters","delimiters","openersBottom","max","length","headerIdx","lastTokenIdx","jumps","closerIdx","closer","push","marker","token","close","hasOwnProperty","minOpenerIdx","open","openerIdx","newMinOpenerIdx","opener","end","isOddMatch","lastJump","link_pairs","state","tokens_meta","curr"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_inline/balance_pairs.mjs"],"sourcesContent":["// For each opening emphasis-like marker find a matching closing one\n//\n\nfunction processDelimiters (delimiters) {\n  const openersBottom = {}\n  const max = delimiters.length\n\n  if (!max) return\n\n  // headerIdx is the first delimiter of the current (where closer is) delimiter run\n  let headerIdx = 0\n  let lastTokenIdx = -2 // needs any value lower than -1\n  const jumps = []\n\n  for (let closerIdx = 0; closerIdx < max; closerIdx++) {\n    const closer = delimiters[closerIdx]\n\n    jumps.push(0)\n\n    // markers belong to same delimiter run if:\n    //  - they have adjacent tokens\n    //  - AND markers are the same\n    //\n    if (delimiters[headerIdx].marker !== closer.marker || lastTokenIdx !== closer.token - 1) {\n      headerIdx = closerIdx\n    }\n\n    lastTokenIdx = closer.token\n\n    // Length is only used for emphasis-specific \"rule of 3\",\n    // if it's not defined (in strikethrough or 3rd party plugins),\n    // we can default it to 0 to disable those checks.\n    //\n    closer.length = closer.length || 0\n\n    if (!closer.close) continue\n\n    // Previously calculated lower bounds (previous fails)\n    // for each marker, each delimiter length modulo 3,\n    // and for whether this closer can be an opener;\n    // https://github.com/commonmark/cmark/commit/34250e12ccebdc6372b8b49c44fab57c72443460\n    /* eslint-disable-next-line no-prototype-builtins */\n    if (!openersBottom.hasOwnProperty(closer.marker)) {\n      openersBottom[closer.marker] = [-1, -1, -1, -1, -1, -1]\n    }\n\n    const minOpenerIdx = openersBottom[closer.marker][(closer.open ? 3 : 0) + (closer.length % 3)]\n\n    let openerIdx = headerIdx - jumps[headerIdx] - 1\n\n    let newMinOpenerIdx = openerIdx\n\n    for (; openerIdx > minOpenerIdx; openerIdx -= jumps[openerIdx] + 1) {\n      const opener = delimiters[openerIdx]\n\n      if (opener.marker !== closer.marker) continue\n\n      if (opener.open && opener.end < 0) {\n        let isOddMatch = false\n\n        // from spec:\n        //\n        // If one of the delimiters can both open and close emphasis, then the\n        // sum of the lengths of the delimiter runs containing the opening and\n        // closing delimiters must not be a multiple of 3 unless both lengths\n        // are multiples of 3.\n        //\n        if (opener.close || closer.open) {\n          if ((opener.length + closer.length) % 3 === 0) {\n            if (opener.length % 3 !== 0 || closer.length % 3 !== 0) {\n              isOddMatch = true\n            }\n          }\n        }\n\n        if (!isOddMatch) {\n          // If previous delimiter cannot be an opener, we can safely skip\n          // the entire sequence in future checks. This is required to make\n          // sure algorithm has linear complexity (see *_*_*_*_*_... case).\n          //\n          const lastJump = openerIdx > 0 && !delimiters[openerIdx - 1].open\n            ? jumps[openerIdx - 1] + 1\n            : 0\n\n          jumps[closerIdx] = closerIdx - openerIdx + lastJump\n          jumps[openerIdx] = lastJump\n\n          closer.open  = false\n          opener.end   = closerIdx\n          opener.close = false\n          newMinOpenerIdx = -1\n          // treat next token as start of run,\n          // it optimizes skips in **<...>**a**<...>** pathological case\n          lastTokenIdx = -2\n          break\n        }\n      }\n    }\n\n    if (newMinOpenerIdx !== -1) {\n      // If match for this delimiter run failed, we want to set lower bound for\n      // future lookups. This is required to make sure algorithm has linear\n      // complexity.\n      //\n      // See details here:\n      // https://github.com/commonmark/cmark/issues/178#issuecomment-270417442\n      //\n      openersBottom[closer.marker][(closer.open ? 3 : 0) + ((closer.length || 0) % 3)] = newMinOpenerIdx\n    }\n  }\n}\n\nexport default function link_pairs (state) {\n  const tokens_meta = state.tokens_meta\n  const max = state.tokens_meta.length\n\n  processDelimiters(state.delimiters)\n\n  for (let curr = 0; curr < max; curr++) {\n    if (tokens_meta[curr] && tokens_meta[curr].delimiters) {\n      processDelimiters(tokens_meta[curr].delimiters)\n    }\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}