{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// HTML block\n\nimport block_names from '../common/html_blocks.mjs';\nimport { HTML_OPEN_CLOSE_TAG_RE } from '../common/html_re.mjs';\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nconst HTML_SEQUENCES = [[/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true], [/^<!--/, /-->/, true], [/^<\\?/, /\\?>/, true], [/^<![A-Z]/, />/, true], [/^<!\\[CDATA\\[/, /\\]\\]>/, true], [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true], [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'), /^$/, false]];\nexport default function html_block(state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine];\n  let max = state.eMarks[startLine];\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  if (!state.md.options.html) {\n    return false;\n  }\n  if (state.src.charCodeAt(pos) !== 0x3C /* < */) {\n    return false;\n  }\n  let lineText = state.src.slice(pos, max);\n  let i = 0;\n  for (; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) {\n      break;\n    }\n  }\n  if (i === HTML_SEQUENCES.length) {\n    return false;\n  }\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2];\n  }\n  let nextLine = startLine + 1;\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) {\n        break;\n      }\n      pos = state.bMarks[nextLine] + state.tShift[nextLine];\n      max = state.eMarks[nextLine];\n      lineText = state.src.slice(pos, max);\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) {\n          nextLine++;\n        }\n        break;\n      }\n    }\n  }\n  state.line = nextLine;\n  const token = state.push('html_block', '', 0);\n  token.map = [startLine, nextLine];\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true);\n  return true;\n}","map":{"version":3,"names":["block_names","HTML_OPEN_CLOSE_TAG_RE","HTML_SEQUENCES","RegExp","join","source","html_block","state","startLine","endLine","silent","pos","bMarks","tShift","max","eMarks","sCount","blkIndent","md","options","html","src","charCodeAt","lineText","slice","i","length","test","nextLine","line","token","push","map","content","getLines"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_block/html_block.mjs"],"sourcesContent":["// HTML block\n\nimport block_names from '../common/html_blocks.mjs'\nimport { HTML_OPEN_CLOSE_TAG_RE } from '../common/html_re.mjs'\n\n// An array of opening and corresponding closing sequences for html tags,\n// last argument defines whether it can terminate a paragraph or not\n//\nconst HTML_SEQUENCES = [\n  [/^<(script|pre|style|textarea)(?=(\\s|>|$))/i, /<\\/(script|pre|style|textarea)>/i, true],\n  [/^<!--/,        /-->/,   true],\n  [/^<\\?/,         /\\?>/,   true],\n  [/^<![A-Z]/,     />/,     true],\n  [/^<!\\[CDATA\\[/, /\\]\\]>/, true],\n  [new RegExp('^</?(' + block_names.join('|') + ')(?=(\\\\s|/?>|$))', 'i'), /^$/, true],\n  [new RegExp(HTML_OPEN_CLOSE_TAG_RE.source + '\\\\s*$'),  /^$/, false]\n]\n\nexport default function html_block (state, startLine, endLine, silent) {\n  let pos = state.bMarks[startLine] + state.tShift[startLine]\n  let max = state.eMarks[startLine]\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n\n  if (!state.md.options.html) { return false }\n\n  if (state.src.charCodeAt(pos) !== 0x3C/* < */) { return false }\n\n  let lineText = state.src.slice(pos, max)\n\n  let i = 0\n  for (; i < HTML_SEQUENCES.length; i++) {\n    if (HTML_SEQUENCES[i][0].test(lineText)) { break }\n  }\n  if (i === HTML_SEQUENCES.length) { return false }\n\n  if (silent) {\n    // true if this sequence can be a terminator, false otherwise\n    return HTML_SEQUENCES[i][2]\n  }\n\n  let nextLine = startLine + 1\n\n  // If we are here - we detected HTML block.\n  // Let's roll down till block end.\n  if (!HTML_SEQUENCES[i][1].test(lineText)) {\n    for (; nextLine < endLine; nextLine++) {\n      if (state.sCount[nextLine] < state.blkIndent) { break }\n\n      pos = state.bMarks[nextLine] + state.tShift[nextLine]\n      max = state.eMarks[nextLine]\n      lineText = state.src.slice(pos, max)\n\n      if (HTML_SEQUENCES[i][1].test(lineText)) {\n        if (lineText.length !== 0) { nextLine++ }\n        break\n      }\n    }\n  }\n\n  state.line = nextLine\n\n  const token   = state.push('html_block', '', 0)\n  token.map     = [startLine, nextLine]\n  token.content = state.getLines(startLine, nextLine, state.blkIndent, true)\n\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}