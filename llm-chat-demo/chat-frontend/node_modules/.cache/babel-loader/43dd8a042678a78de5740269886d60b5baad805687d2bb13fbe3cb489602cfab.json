{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// GFM table, https://github.github.com/gfm/#tables-extension-\n\nimport { isSpace } from '../common/utils.mjs';\n\n// Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000;\nfunction getLine(state, line) {\n  const pos = state.bMarks[line] + state.tShift[line];\n  const max = state.eMarks[line];\n  return state.src.slice(pos, max);\n}\nfunction escapedSplit(str) {\n  const result = [];\n  const max = str.length;\n  let pos = 0;\n  let ch = str.charCodeAt(pos);\n  let isEscaped = false;\n  let lastPos = 0;\n  let current = '';\n  while (pos < max) {\n    if (ch === 0x7c /* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos));\n        current = '';\n        lastPos = pos + 1;\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1);\n        lastPos = pos;\n      }\n    }\n    isEscaped = ch === 0x5c /* \\ */;\n    pos++;\n    ch = str.charCodeAt(pos);\n  }\n  result.push(current + str.substring(lastPos));\n  return result;\n}\nexport default function table(state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n  let nextLine = startLine + 1;\n  if (state.sCount[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) {\n    return false;\n  }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine];\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n  const firstCh = state.src.charCodeAt(pos++);\n  if (firstCh !== 0x7C /* | */ && firstCh !== 0x2D /* - */ && firstCh !== 0x3A /* : */) {\n    return false;\n  }\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n  const secondCh = state.src.charCodeAt(pos++);\n  if (secondCh !== 0x7C /* | */ && secondCh !== 0x2D /* - */ && secondCh !== 0x3A /* : */ && !isSpace(secondCh)) {\n    return false;\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D /* - */ && isSpace(secondCh)) {\n    return false;\n  }\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos);\n    if (ch !== 0x7C /* | */ && ch !== 0x2D /* - */ && ch !== 0x3A /* : */ && !isSpace(ch)) {\n      return false;\n    }\n    pos++;\n  }\n  let lineText = getLine(state, startLine + 1);\n  let columns = lineText.split('|');\n  const aligns = [];\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim();\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n    if (!/^:?-+:?$/.test(t)) {\n      return false;\n    }\n    if (t.charCodeAt(t.length - 1) === 0x3A /* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A /* : */ ? 'center' : 'right');\n    } else if (t.charCodeAt(0) === 0x3A /* : */) {\n      aligns.push('left');\n    } else {\n      aligns.push('');\n    }\n  }\n  lineText = getLine(state, startLine).trim();\n  if (lineText.indexOf('|') === -1) {\n    return false;\n  }\n  if (state.sCount[startLine] - state.blkIndent >= 4) {\n    return false;\n  }\n  columns = escapedSplit(lineText);\n  if (columns.length && columns[0] === '') columns.shift();\n  if (columns.length && columns[columns.length - 1] === '') columns.pop();\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  const columnCount = columns.length;\n  if (columnCount === 0 || columnCount !== aligns.length) {\n    return false;\n  }\n  if (silent) {\n    return true;\n  }\n  const oldParentType = state.parentType;\n  state.parentType = 'table';\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  const terminatorRules = state.md.block.ruler.getRules('blockquote');\n  const token_to = state.push('table_open', 'table', 1);\n  const tableLines = [startLine, 0];\n  token_to.map = tableLines;\n  const token_tho = state.push('thead_open', 'thead', 1);\n  token_tho.map = [startLine, startLine + 1];\n  const token_htro = state.push('tr_open', 'tr', 1);\n  token_htro.map = [startLine, startLine + 1];\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1);\n    if (aligns[i]) {\n      token_ho.attrs = [['style', 'text-align:' + aligns[i]]];\n    }\n    const token_il = state.push('inline', '', 0);\n    token_il.content = columns[i].trim();\n    token_il.children = [];\n    state.push('th_close', 'th', -1);\n  }\n  state.push('tr_close', 'tr', -1);\n  state.push('thead_close', 'thead', -1);\n  let tbodyLines;\n  let autocompletedCells = 0;\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) {\n      break;\n    }\n    let terminate = false;\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n    if (terminate) {\n      break;\n    }\n    lineText = getLine(state, nextLine).trim();\n    if (!lineText) {\n      break;\n    }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) {\n      break;\n    }\n    columns = escapedSplit(lineText);\n    if (columns.length && columns[0] === '') columns.shift();\n    if (columns.length && columns[columns.length - 1] === '') columns.pop();\n\n    // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n    autocompletedCells += columnCount - columns.length;\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) {\n      break;\n    }\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1);\n      token_tbo.map = tbodyLines = [startLine + 2, 0];\n    }\n    const token_tro = state.push('tr_open', 'tr', 1);\n    token_tro.map = [nextLine, nextLine + 1];\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1);\n      if (aligns[i]) {\n        token_tdo.attrs = [['style', 'text-align:' + aligns[i]]];\n      }\n      const token_il = state.push('inline', '', 0);\n      token_il.content = columns[i] ? columns[i].trim() : '';\n      token_il.children = [];\n      state.push('td_close', 'td', -1);\n    }\n    state.push('tr_close', 'tr', -1);\n  }\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1);\n    tbodyLines[1] = nextLine;\n  }\n  state.push('table_close', 'table', -1);\n  tableLines[1] = nextLine;\n  state.parentType = oldParentType;\n  state.line = nextLine;\n  return true;\n}","map":{"version":3,"names":["isSpace","MAX_AUTOCOMPLETED_CELLS","getLine","state","line","pos","bMarks","tShift","max","eMarks","src","slice","escapedSplit","str","result","length","ch","charCodeAt","isEscaped","lastPos","current","push","substring","table","startLine","endLine","silent","nextLine","sCount","blkIndent","firstCh","secondCh","lineText","columns","split","aligns","i","t","trim","test","indexOf","shift","pop","columnCount","oldParentType","parentType","terminatorRules","md","block","ruler","getRules","token_to","tableLines","map","token_tho","token_htro","token_ho","attrs","token_il","content","children","tbodyLines","autocompletedCells","terminate","l","token_tbo","token_tro","token_tdo"],"sources":["E:/GLM-UML/llm-chat-demo/chat-frontend/node_modules/markdown-it/lib/rules_block/table.mjs"],"sourcesContent":["// GFM table, https://github.github.com/gfm/#tables-extension-\n\nimport { isSpace } from '../common/utils.mjs'\n\n// Limit the amount of empty autocompleted cells in a table,\n// see https://github.com/markdown-it/markdown-it/issues/1000,\n//\n// Both pulldown-cmark and commonmark-hs limit the number of cells this way to ~200k.\n// We set it to 65k, which can expand user input by a factor of x370\n// (256x256 square is 1.8kB expanded into 650kB).\nconst MAX_AUTOCOMPLETED_CELLS = 0x10000\n\nfunction getLine (state, line) {\n  const pos = state.bMarks[line] + state.tShift[line]\n  const max = state.eMarks[line]\n\n  return state.src.slice(pos, max)\n}\n\nfunction escapedSplit (str) {\n  const result = []\n  const max = str.length\n\n  let pos = 0\n  let ch = str.charCodeAt(pos)\n  let isEscaped = false\n  let lastPos = 0\n  let current = ''\n\n  while (pos < max) {\n    if (ch === 0x7c/* | */) {\n      if (!isEscaped) {\n        // pipe separating cells, '|'\n        result.push(current + str.substring(lastPos, pos))\n        current = ''\n        lastPos = pos + 1\n      } else {\n        // escaped pipe, '\\|'\n        current += str.substring(lastPos, pos - 1)\n        lastPos = pos\n      }\n    }\n\n    isEscaped = (ch === 0x5c/* \\ */)\n    pos++\n\n    ch = str.charCodeAt(pos)\n  }\n\n  result.push(current + str.substring(lastPos))\n\n  return result\n}\n\nexport default function table (state, startLine, endLine, silent) {\n  // should have at least two lines\n  if (startLine + 2 > endLine) { return false }\n\n  let nextLine = startLine + 1\n\n  if (state.sCount[nextLine] < state.blkIndent) { return false }\n\n  // if it's indented more than 3 spaces, it should be a code block\n  if (state.sCount[nextLine] - state.blkIndent >= 4) { return false }\n\n  // first character of the second line should be '|', '-', ':',\n  // and no other characters are allowed but spaces;\n  // basically, this is the equivalent of /^[-:|][-:|\\s]*$/ regexp\n\n  let pos = state.bMarks[nextLine] + state.tShift[nextLine]\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const firstCh = state.src.charCodeAt(pos++)\n  if (firstCh !== 0x7C/* | */ && firstCh !== 0x2D/* - */ && firstCh !== 0x3A/* : */) { return false }\n\n  if (pos >= state.eMarks[nextLine]) { return false }\n\n  const secondCh = state.src.charCodeAt(pos++)\n  if (secondCh !== 0x7C/* | */ && secondCh !== 0x2D/* - */ && secondCh !== 0x3A/* : */ && !isSpace(secondCh)) {\n    return false\n  }\n\n  // if first character is '-', then second character must not be a space\n  // (due to parsing ambiguity with list)\n  if (firstCh === 0x2D/* - */ && isSpace(secondCh)) { return false }\n\n  while (pos < state.eMarks[nextLine]) {\n    const ch = state.src.charCodeAt(pos)\n\n    if (ch !== 0x7C/* | */ && ch !== 0x2D/* - */ && ch !== 0x3A/* : */ && !isSpace(ch)) { return false }\n\n    pos++\n  }\n\n  let lineText = getLine(state, startLine + 1)\n  let columns = lineText.split('|')\n  const aligns = []\n  for (let i = 0; i < columns.length; i++) {\n    const t = columns[i].trim()\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === columns.length - 1) {\n        continue\n      } else {\n        return false\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) { return false }\n    if (t.charCodeAt(t.length - 1) === 0x3A/* : */) {\n      aligns.push(t.charCodeAt(0) === 0x3A/* : */ ? 'center' : 'right')\n    } else if (t.charCodeAt(0) === 0x3A/* : */) {\n      aligns.push('left')\n    } else {\n      aligns.push('')\n    }\n  }\n\n  lineText = getLine(state, startLine).trim()\n  if (lineText.indexOf('|') === -1) { return false }\n  if (state.sCount[startLine] - state.blkIndent >= 4) { return false }\n  columns = escapedSplit(lineText)\n  if (columns.length && columns[0] === '') columns.shift()\n  if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n  // header row will define an amount of columns in the entire table,\n  // and align row should be exactly the same (the rest of the rows can differ)\n  const columnCount = columns.length\n  if (columnCount === 0 || columnCount !== aligns.length) { return false }\n\n  if (silent) { return true }\n\n  const oldParentType = state.parentType\n  state.parentType = 'table'\n\n  // use 'blockquote' lists for termination because it's\n  // the most similar to tables\n  const terminatorRules = state.md.block.ruler.getRules('blockquote')\n\n  const token_to = state.push('table_open', 'table', 1)\n  const tableLines = [startLine, 0]\n  token_to.map = tableLines\n\n  const token_tho = state.push('thead_open', 'thead', 1)\n  token_tho.map = [startLine, startLine + 1]\n\n  const token_htro = state.push('tr_open', 'tr', 1)\n  token_htro.map = [startLine, startLine + 1]\n\n  for (let i = 0; i < columns.length; i++) {\n    const token_ho = state.push('th_open', 'th', 1)\n    if (aligns[i]) {\n      token_ho.attrs  = [['style', 'text-align:' + aligns[i]]]\n    }\n\n    const token_il = state.push('inline', '', 0)\n    token_il.content  = columns[i].trim()\n    token_il.children = []\n\n    state.push('th_close', 'th', -1)\n  }\n\n  state.push('tr_close', 'tr', -1)\n  state.push('thead_close', 'thead', -1)\n\n  let tbodyLines\n  let autocompletedCells = 0\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.sCount[nextLine] < state.blkIndent) { break }\n\n    let terminate = false\n    for (let i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true\n        break\n      }\n    }\n\n    if (terminate) { break }\n    lineText = getLine(state, nextLine).trim()\n    if (!lineText) { break }\n    if (state.sCount[nextLine] - state.blkIndent >= 4) { break }\n    columns = escapedSplit(lineText)\n    if (columns.length && columns[0] === '') columns.shift()\n    if (columns.length && columns[columns.length - 1] === '') columns.pop()\n\n    // note: autocomplete count can be negative if user specifies more columns than header,\n    // but that does not affect intended use (which is limiting expansion)\n    autocompletedCells += columnCount - columns.length\n    if (autocompletedCells > MAX_AUTOCOMPLETED_CELLS) { break }\n\n    if (nextLine === startLine + 2) {\n      const token_tbo = state.push('tbody_open', 'tbody', 1)\n      token_tbo.map = tbodyLines = [startLine + 2, 0]\n    }\n\n    const token_tro = state.push('tr_open', 'tr', 1)\n    token_tro.map = [nextLine, nextLine + 1]\n\n    for (let i = 0; i < columnCount; i++) {\n      const token_tdo = state.push('td_open', 'td', 1)\n      if (aligns[i]) {\n        token_tdo.attrs  = [['style', 'text-align:' + aligns[i]]]\n      }\n\n      const token_il = state.push('inline', '', 0)\n      token_il.content  = columns[i] ? columns[i].trim() : ''\n      token_il.children = []\n\n      state.push('td_close', 'td', -1)\n    }\n    state.push('tr_close', 'tr', -1)\n  }\n\n  if (tbodyLines) {\n    state.push('tbody_close', 'tbody', -1)\n    tbodyLines[1] = nextLine\n  }\n\n  state.push('table_close', 'table', -1)\n  tableLines[1] = nextLine\n\n  state.parentType = oldParentType\n  state.line = nextLine\n  return true\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}